<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Ultra Otimizado - Sistema Completo</title>
  <link rel="stylesheet" href="style.css">

</head>
<body>
<div id="main-menu">
  <div class="menu-container">
    <h1 class="menu-title">‚õèÔ∏è MINECRAFT ULTRA OTIMIZADO ‚õèÔ∏è</h1>

    <p class="menu-subtitle">
      Uma experi√™ncia completa de Minecraft com gr√°ficos otimizados, sistema de vida,
      animais e invent√°rio expandido. Tudo rodando diretamente no seu navegador!
    </p>

    <div class="controls-grid">
      <div class="control-item">
        <strong>W/A/S/D</strong>
        <span>Movimenta√ß√£o</span>
      </div>
      <div class="control-item">
        <strong>ESPA√áO</strong>
        <span>Pular</span>
      </div>
      <div class="control-item">
        <strong>SHIFT</strong>
        <span>Correr / Descer (Voo)</span>
      </div>
      <div class="control-item">
        <strong>MOUSE</strong>
        <span>Olhar ao redor</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE ESQUERDO</strong>
        <span>Quebrar bloco</span>
      </div>
      <div class="control-item">
        <strong>CLIQUE DIREITO</strong>
        <span>Colocar bloco</span>
      </div>
      <div class="control-item">
        <strong>SCROLL / 1-9</strong>
        <span>Trocar bloco</span>
      </div>
      <div class="control-item">
        <strong>F</strong>
        <span>Alternar Modo Voo</span>
      </div>
      <div class="control-item">
        <strong>E</strong>
        <span>Abrir Invent√°rio</span>
      </div>
      <div class="control-item">
        <strong>Q</strong>
        <span>Jogar Item</span>
      </div>
    </div>

    <div class="features-grid">
      <div class="feature">
        <span class="feature-icon">‚ö°</span>
        <span class="feature-text">Alto Desempenho</span>
      </div>
      <div class="feature">
        <span class="feature-icon">‚ù§Ô∏è</span>
        <span class="feature-text">Sistema de Vida</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üêÆ</span>
        <span class="feature-text">Animais Interativos</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üéí</span>
        <span class="feature-text">36 Slots</span>
      </div>
      <div class="feature">
        <span class="feature-icon">üåç</span>
        <span class="feature-text">Mundo Gerado</span>
      </div>
    </div>

    <button class="start-button" onclick="startGame()">
      üéÆ INICIAR JOGO
    </button>

    <p class="menu-footer">
      Desenvolvido com Three.js ‚Ä¢ Otimizado para navegadores modernos
    </p>
  </div>
</div>

<div id="info">
  <div class="info-item"><strong>Posi√ß√£o:</strong> <span id="pos" class="highlight">0, 0, 0</span></div>
  <div class="info-item"><strong>FPS:</strong> <span id="fps" class="performance-good">60</span></div>
  <div class="info-item"><strong>Chunks:</strong> <span id="chunks" class="highlight">0</span></div>
  <div class="info-item"><strong>Faces:</strong> <span id="visible" class="highlight">0</span></div>
  <div class="info-item"><strong>Blocos:</strong> <span id="total" class="highlight">0</span></div>
  <div class="info-item"><strong>Animais:</strong> <span id="animals-count" class="highlight">0</span></div>
  <div class="info-item"><strong>Modo:</strong> <span id="mode" class="highlight">Normal</span></div>
  <div class="info-item"><strong>Bloco:</strong> <span id="selected-block" class="highlight">Grama</span></div>
</div>

<div id="health-container"></div>
<div id="crosshair"></div>
<div class="break-progress" id="break-progress">
  <div class="break-progress-fill"></div>
</div>
<div id="inventory-bar"></div>
<div id="inventory-full"></div>

<!-- Controles Mobile -->
<div class="mobile-controls">
  <!-- Joystick Virtual -->
  <div id="mobile-joystick">
    <div id="joystick-stick"></div>
  </div>

  <!-- √Årea de Look Around -->
  <div id="mobile-look"></div>

  <!-- Bot√µes de A√ß√£o -->
  <div class="mobile-buttons">
    <button class="mobile-btn" id="mobile-jump">‚Üë</button>
    <button class="mobile-btn" id="mobile-break">‚öí</button>
    <button class="mobile-btn" id="mobile-place">+</button>
  </div>

  <!-- Bot√µes Superiores -->
  <div class="mobile-top-buttons">
    <button class="mobile-top-btn" id="mobile-fly">‚úà</button>
    <button class="mobile-top-btn" id="mobile-inventory">üéí</button>
    <button class="mobile-top-btn" id="mobile-sprint">‚ö°</button>
  </div>
</div>

<button class="mobile-top-btn" id="mobile-prev-slot">‚óÄ</button>
<button class="mobile-top-btn" id="mobile-next-slot">‚ñ∂</button>

<div id="settings-menu">
  <div class="settings-container">
    <div class="settings-header">
      <h2>‚öôÔ∏è CONFIGURA√á√ïES</h2>
      <button class="close-settings" onclick="closeSettings()">√ó</button>
    </div>

    <!-- Tabs -->
    <div class="settings-tabs">
      <button class="settings-tab active" onclick="switchTab('graphics')">üé® Gr√°ficos</button>
      <button class="settings-tab" onclick="switchTab('gameplay')">üéÆ Gameplay</button>
      <button class="settings-tab" onclick="switchTab('controls')">‚å®Ô∏è Controles</button>
      <button class="settings-tab" onclick="switchTab('audio')">üîä √Åudio</button>
      <button class="settings-tab" onclick="switchTab('info')">‚ÑπÔ∏è Info</button>
    </div>

    <!-- Conte√∫do: Gr√°ficos -->
    <div id="tab-graphics" class="settings-content active">
      <div class="settings-group">
        <h3>Qualidade Visual</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dist√¢ncia de Renderiza√ß√£o</span>
            <span class="setting-description">Quantos chunks s√£o carregados ao redor do jogador</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="render-distance" min="1" max="12" value="1"
                     oninput="updateSetting('renderDistance', this.value)">
              <span class="slider-value" id="render-distance-value">1</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Antialiasing</span>
            <span class="setting-description">Suaviza bordas dos objetos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="antialiasing-switch" onclick="toggleSwitch('antialiasing')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sombras</span>
            <span class="setting-description">Renderizar sombras din√¢micas</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="shadows-switch" onclick="toggleSwitch('shadows')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>N√©voa</span>
            <span class="setting-description">Efeito de n√©voa atmosf√©rica</span>
          </div>
          <div class="setting-control">
            <div class="switch active" id="fog-switch" onclick="toggleSwitch('fog')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Part√≠culas</span>
            <span class="setting-description">Intensidade de efeitos de part√≠culas</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="particles-select" onchange="updateSetting('particles', this.value)">
              <option value="all">Todas</option>
              <option value="minimal">M√≠nimas</option>
              <option value="none">Desativadas</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>FPS Alvo</span>
            <span class="setting-description">Limite de quadros por segundo</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="fps-select" onchange="updateSetting('fpsLimit', this.value)">
              <option value="unlimited">Ilimitado</option>
              <option value="144">144 FPS</option>
              <option value="120">120 FPS</option>
              <option value="60">60 FPS</option>
              <option value="30">30 FPS</option>
            </select>
          </div>
        </div>
      </div>

      <div class="info-box">
        üí° Dica: Reduzir a dist√¢ncia de renderiza√ß√£o e desativar sombras pode melhorar significativamente a performance.
      </div>
    </div>

    <!-- Conte√∫do: Gameplay -->
    <div id="tab-gameplay" class="settings-content">
      <div class="settings-group">
        <h3>Mec√¢nicas de Jogo</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Dificuldade</span>
            <span class="setting-description">Altera dano de inimigos e spawn</span>
          </div>
          <div class="setting-control">
            <select class="custom-select" id="difficulty-select" onchange="updateSetting('difficulty', this.value)">
              <option value="peaceful">Pac√≠fico</option>
              <option value="easy">F√°cil</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Dif√≠cil</option>
            </select>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Modo Criativo</span>
            <span class="setting-description">Recursos ilimitados e invencibilidade</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="creative-switch" onclick="toggleSwitch('creative')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Auto-Jump</span>
            <span class="setting-description">Pular automaticamente ao encontrar obst√°culos</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="autojump-switch" onclick="toggleSwitch('autoJump')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Spawn de Inimigos</span>
            <span class="setting-description">Frequ√™ncia de apari√ß√£o de mobs hostis</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mob-spawn" min="0" max="100" value="50"
                     oninput="updateSetting('mobSpawn', this.value)">
              <span class="slider-value" id="mob-spawn-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Regenera√ß√£o de Vida</span>
            <span class="setting-description">Velocidade de recupera√ß√£o de HP</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="health-regen" min="0" max="10" value="5"
                     oninput="updateSetting('healthRegen', this.value)">
              <span class="slider-value" id="health-regen-value">5</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Conte√∫do: Controles -->
    <div id="tab-controls" class="settings-content">
      <div class="settings-group">
        <h3>Sensibilidade</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade do Mouse</span>
            <span class="setting-description">Velocidade de rota√ß√£o da c√¢mera</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="mouse-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('mouseSensitivity', this.value)">
              <span class="slider-value" id="mouse-sensitivity-value">10</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Inverter Eixo Y</span>
            <span class="setting-description">Inverter dire√ß√£o vertical do mouse</span>
          </div>
          <div class="setting-control">
            <div class="switch" id="invert-y-switch" onclick="toggleSwitch('invertY')">
              <div class="switch-handle"></div>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sensibilidade Touch (Mobile)</span>
            <span class="setting-description">Velocidade de rota√ß√£o no mobile</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="touch-sensitivity" min="1" max="20" value="10"
                     oninput="updateSetting('touchSensitivity', this.value)">
              <span class="slider-value" id="touch-sensitivity-value">10</span>
            </div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Atalhos de Teclado</h3>
        <div class="info-box">
          <strong>Controles Atuais:</strong><br>
          ‚Ä¢ WASD - Movimento<br>
          ‚Ä¢ Espa√ßo - Pular<br>
          ‚Ä¢ Shift - Correr/Descer<br>
          ‚Ä¢ F - Modo Voo<br>
          ‚Ä¢ E - Invent√°rio<br>
          ‚Ä¢ Q - Jogar Item<br>
          ‚Ä¢ 1-9 - Selecionar Slot<br>
          ‚Ä¢ Mouse - Olhar / Interagir
        </div>
        <button class="action-button">üîÑ Restaurar Padr√£o</button>
      </div>
    </div>

    <!-- Conte√∫do: √Åudio -->
    <div id="tab-audio" class="settings-content">
      <div class="settings-group">
        <h3>Volume</h3>

        <div class="setting-item">
          <div class="setting-label">
            <span>Volume Mestre</span>
            <span class="setting-description">Volume geral do jogo</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="master-volume" min="0" max="100" value="70"
                     oninput="updateSetting('masterVolume', this.value)">
              <span class="slider-value" id="master-volume-value">70%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Efeitos Sonoros</span>
            <span class="setting-description">Volume de sons de a√ß√£o</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="sfx-volume" min="0" max="100" value="80"
                     oninput="updateSetting('sfxVolume', this.value)">
              <span class="slider-value" id="sfx-volume-value">80%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>M√∫sica de Fundo</span>
            <span class="setting-description">Volume da m√∫sica ambiente</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="music-volume" min="0" max="100" value="50"
                     oninput="updateSetting('musicVolume', this.value)">
              <span class="slider-value" id="music-volume-value">50%</span>
            </div>
          </div>
        </div>

        <div class="setting-item">
          <div class="setting-label">
            <span>Sons Ambiente</span>
            <span class="setting-description">Sons de natureza e clima</span>
          </div>
          <div class="setting-control">
            <div class="slider-container">
              <input type="range" class="slider" id="ambient-volume" min="0" max="100" value="60"
                     oninput="updateSetting('ambientVolume', this.value)">
              <span class="slider-value" id="ambient-volume-value">60%</span>
            </div>
          </div>
        </div>
      </div>

      <div class="warning-box">
        ‚ö†Ô∏è Nota: Sistema de √°udio ser√° implementado em vers√£o futura.
      </div>
    </div>

    <!-- Conte√∫do: Info -->
    <div id="tab-info" class="settings-content">
      <div class="settings-group">
        <h3>Informa√ß√µes do Sistema</h3>

        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-fps">60</div>
            <div class="stat-label">FPS Atual</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-chunks">0</div>
            <div class="stat-label">Chunks Carregados</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-entities">0</div>
            <div class="stat-label">Entidades</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-memory">--</div>
            <div class="stat-label">Mem√≥ria Usada</div>
          </div>
        </div>
      </div>

      <div class="settings-group">
        <h3>Sobre o Jogo</h3>
        <div class="info-box">
          <strong>Minecraft Ultra Otimizado</strong><br>
          Vers√£o: 1.0.0<br>
          Motor: Three.js r128<br>
          <br>
          Desenvolvido com foco em performance e jogabilidade.<br>
          <br>
          ¬© 2026 - Todos os direitos reservados
        </div>
      </div>

      <div class="settings-group">
        <h3>Dados do Jogo</h3>
        <button class="action-button" onclick="exportGameData()">üì• Exportar Mundo</button>
        <button class="action-button" onclick="importGameData()">üì§ Importar Mundo</button>
        <button class="action-button danger" onclick="resetGameData()">üóëÔ∏è Limpar Todos os Dados</button>
      </div>
    </div>

    <!-- Bot√µes de Controle -->
    <div class="control-buttons">
      <button class="action-button" onclick="saveSettings()">üíæ Salvar</button>
      <button class="action-button" onclick="resetSettings()">üîÑ Restaurar Padr√£o</button>
      <button class="action-button" onclick="closeSettings()">‚úñÔ∏è Fechar</button>
    </div>
  </div>
</div>

<div id="multiplayer-status" class="hidden">
  <div class="mp-status-line">
    <span>Status:</span>
    <span id="mp-status" class="mp-disconnected">Desconectado</span>
  </div>
  <div class="mp-status-line">
    <span>Jogadores:</span>
    <span id="mp-players-count">0</span>
  </div>
</div>

<div id="multiplayer-chat">
  <div id="chat-messages"></div>
  <div id="chat-input-container">
    <input type="text" id="chat-input" placeholder="Digite sua mensagem... (Enter para enviar)" maxlength="200">
    <button id="chat-send" onclick="sendChatMessage(document.getElementById('chat-input').value)">Enviar</button>
  </div>
</div>

<!-- Menu Multiplayer -->
<div id="multiplayer-menu">
  <h2 class="mp-menu-title">üåê MULTIPLAYER</h2>

  <div class="mp-menu-section">
    <h3>Conex√£o</h3>

    <div class="mp-input-group">
      <label>Servidor:</label>
      <input type="text" id="mp-server-url" value="ws://localhost:8765" placeholder="ws://localhost:8765">
    </div>

    <div class="mp-input-group">
      <label>Seu Nome:</label>
      <input type="text" id="mp-player-name" placeholder="Seu Nome" maxlength="20">
    </div>

    <div class="mp-info-box">
      <span class="mp-status-indicator" id="mp-indicator"></span>
      <span id="mp-connection-status">N√£o conectado</span>
    </div>
  </div>

  <div class="mp-menu-section">
    <h3>Controles</h3>
    <div style="color: white; font-size: 13px; line-height: 1.6;">
      ‚Ä¢ <strong>T</strong> - Abrir chat<br>
      ‚Ä¢ <strong>Enter</strong> - Enviar mensagem<br>
      ‚Ä¢ <strong>ESC</strong> - Fechar chat<br>
    </div>
  </div>

  <button class="mp-button" id="mp-connect-btn" onclick="toggleMultiplayerConnection()">
    Conectar
  </button>

  <button class="mp-button danger" onclick="closeMultiplayerMenu()">
    Fechar
  </button>
</div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="Animals.js"></script>
<script src="PlayerCharacter.js"></script>
<script src="Enemy.js"></script>
<script src="Village.js"></script>
<script src="Villager.js"></script>

<script src="Multiplayer.js"></script>
<script src="Controls.js"></script>
<script src="Menu.js"></script>
<script>
  let scene, camera, renderer, raycaster;
  let worldData = {};
  let chunks = {};
  let chunkMeshes = {};
  let materials = {};
  let breakingAnimations = [];
  let animals = [];
  let animalMeshes = [];
  let MAX_ANIMALS = 100; // Reduzido de ~50 para 25 (50% menos)

  const CHUNK_SIZE = 24;
  const RENDER_DISTANCE = 6;
  const MAX_HEALTH = 20;
  let playerHealth = MAX_HEALTH;

  const player = {
    velocity: new THREE.Vector3(),
    canJump: false,
    selectedSlot: 0,
    flying: false,
    breaking: null,
    breakProgress: 0,
    lastChunk: { x: 0, z: 0 },
    inventorySlots: 36,
    hotbarSlots: 9
  };

  // Sistema de invent√°rio
  player.inventory = Array(player.inventorySlots).fill().map(() => ({
    type: null,
    count: 0
  }));

  let keys = {};
  let mouse = { x: 0, y: 0 };
  let controls = { locked: false };

  const GRAVITY = -0.018;
  const JUMP_SPEED = 0.28;
  const MOVE_SPEED = 0.15;
  const SPRINT_SPEED = 0.28;
  const FLY_SPEED = 0.4;
  const REACH = 7;
  const BREAK_TIME = 500;
  let lastTime = performance.now();
  let frames = 0;
  let lastFaceUpdate = 0;
  const blockTypes = {
    grass: { color: 0x7CFC00, name: 'Grama', hardness: 1 },
    dirt: { color: 0x8B4513, name: 'Terra', hardness: 1 },
    stone: { color: 0x808080, name: 'Pedra', hardness: 3 },
    wood: { color: 0x654321, name: 'Madeira', hardness: 2 },
    leaves: { color: 0x228B22, name: 'Folhas', hardness: 0.5 },
    sand: { color: 0xF4A460, name: 'Areia', hardness: 1 },
    cobblestone: { color: 0x6B6B6B, name: 'Pedregulho', hardness: 3 },
    coal_ore: { color: 0x343434, name: 'Carv√£o', hardness: 4 },
    iron_ore: { color: 0xD8AF93, name: 'Ferro', hardness: 5 },
    gold_ore: { color: 0xFFD700, name: 'Ouro', hardness: 5 },
    diamond_ore: { color: 0x00CED1, name: 'Diamante', hardness: 6 },
    bedrock: { color: 0x2F2F2F, name: 'Bedrock', hardness: 999 },
    planks: { color: 0xC19A6B, name: 'T√°buas', hardness: 2 },
    brick: { color: 0xB22222, name: 'Tijolo', hardness: 3 },
    glass: { color: 0xADD8E6, name: 'Vidro', hardness: 0.3 },
    obsidian: { color: 0x1C1C2E, name: 'Obsidiana', hardness: 8 },
    ice: { color: 0xB0E0E6, name: 'Gelo', hardness: 0.5 },
    snow: { color: 0xFFFAFA, name: 'Neve', hardness: 0.2 },
    gravel: { color: 0x8B8680, name: 'Cascalho', hardness: 1 },
    clay: { color: 0xA0A0A0, name: 'Argila', hardness: 1 },
    emerald_ore: { color: 0x50C878, name: 'Esmeralda', hardness: 6 },
    redstone_ore: { color: 0xFF0000, name: 'Redstone', hardness: 5 },


    // NOVOS BLOCOS ESPECIAIS - LUMINOSOS
    glowstone: { color: 0xFFFF99, name: 'Pedra Luminosa', hardness: 0.5, emissive: true },
    lantern: { color: 0xFFD700, name: 'Lanterna', hardness: 0.5, emissive: true },
    torch: { color: 0xFF8C00, name: 'Tocha', hardness: 0.1, emissive: true },

    // BLOCOS DECORATIVOS
    quartz: { color: 0xF5F5F5, name: 'Quartzo', hardness: 2 },
    prismarine: { color: 0x4ECDC4, name: 'Prismarinho', hardness: 3 },
    purpur: { color: 0xA569BD, name: 'Purpur', hardness: 3 },
    endstone: { color: 0xE4E096, name: 'Pedra do End', hardness: 4 },

    // BLOCOS DE CONSTRU√á√ÉO
    concrete_white: { color: 0xFFFFFF, name: 'Concreto Branco', hardness: 2 },
    concrete_red: { color: 0xDC143C, name: 'Concreto Vermelho', hardness: 2 },
    concrete_blue: { color: 0x1E90FF, name: 'Concreto Azul', hardness: 2 },
    concrete_green: { color: 0x32CD32, name: 'Concreto Verde', hardness: 2 },
    concrete_yellow: { color: 0xFFD700, name: 'Concreto Amarelo', hardness: 2 },
    concrete_black: { color: 0x2F4F4F, name: 'Concreto Preto', hardness: 2 },

    // BLOCOS FUNCIONAIS
    crafting_table: { color: 0x8B4513, name: 'Mesa de Trabalho', hardness: 2.5 },
    furnace: { color: 0x696969, name: 'Fornalha', hardness: 4 },
    chest: { color: 0xA0522D, name: 'Ba√∫', hardness: 2.5 },
    bookshelf: { color: 0x654321, name: 'Estante', hardness: 1.5 },

    // BLOCOS NATURAIS ESPECIAIS
    mushroom_red: { color: 0xFF0000, name: 'Cogumelo Vermelho', hardness: 0.2 },
    mushroom_brown: { color: 0x8B4513, name: 'Cogumelo Marrom', hardness: 0.2 },
    pumpkin: { color: 0xFF8C00, name: 'Ab√≥bora', hardness: 1 },
    melon: { color: 0x90EE90, name: 'Melancia', hardness: 1 },

    // BLOCOS DE MIN√âRIO RAROS
    lapis_ore: { color: 0x0000FF, name: 'L√°pis-laz√∫li', hardness: 4 },
    netherite: { color: 0x8B008B, name: 'Netherite', hardness: 10 }
  };


  const animalTypes = {
    cow: {
      health: 10,
      drops: ['rawBeef', 'leather'],
      dropCount: { min: 1, max: 3 },
      size: { width: 1.2, height: 1.4, depth: 1.8 },
      color: 0x8B4513,
      speed: 0.02
    },
    pig: {
      health: 10,
      drops: ['rawPorkchop'],
      dropCount: { min: 1, max: 3 },
      size: { width: 1.0, height: 0.9, depth: 1.2 },
      color: 0xFFB6C1,
      speed: 0.025
    },
    sheep: {
      health: 8,
      drops: ['wool', 'rawMutton'],
      dropCount: { min: 1, max: 2 },
      size: { width: 1.2, height: 1.3, depth: 1.6 },
      color: 0xFFFFFF,
      speed: 0.02
    },
    chicken: {
      health: 4,
      drops: ['rawChicken', 'feather'],
      dropCount: { min: 0, max: 2 },
      size: { width: 0.6, height: 0.8, depth: 0.6 },
      color: 0xFFFFFF,
      speed: 0.03
    },
    horse: {
      health: 30,
      drops: ['leather'],
      dropCount: { min: 0, max: 2 },
      size: { width: 1.4, height: 1.8, depth: 1.8 },
      color: 0x8B4513,
      speed: 0.04
    },
    rabbit: {
      health: 3,
      drops: ['rawRabbit', 'rabbitHide'],
      dropCount: { min: 0, max: 1 },
      size: { width: 0.5, height: 0.5, depth: 0.7 },
      color: 0xD2B48C,
      speed: 0.045
    },
    wolf: {
      health: 8,
      drops: [],
      dropCount: { min: 0, max: 0 },
      size: { width: 0.8, height: 0.9, depth: 1.2 },
      color: 0x808080,
      speed: 0.035
    },
    cat: {
      health: 10,
      drops: ['string'],
      dropCount: { min: 0, max: 2 },
      size: { width: 0.6, height: 0.7, depth: 0.8 },
      color: 0xFF8C00,
      speed: 0.03
    }
  };

  const itemTypes = {
    ...blockTypes,
    leather: { color: 0x8B4513, name: 'Couro' },
    beef: { color: 0x8B0000, name: 'Carne Bovina' },
    pork: { color: 0xFFC0CB, name: 'Carne de Porco' },
    wool: { color: 0xFFFFFF, name: 'L√£' }
  };

  const PLAYER_WIDTH = 0.6;
  const PLAYER_HEIGHT = 1.8;
  const PLAYER_EYE_HEIGHT = 1.6;
  const COLLISION_TOLERANCE = 0.01;

  let enemies = [];
  let enemyMeshes = [];

  let villagers = [];
  let villagerMeshes = [];
  let villages = [];

  let playerModel = null;

  let walkAnimTime = 0;

  const multiplayer = {
    enabled: false,
    connected: false,
    ws: null,
    serverUrl: 'ws://localhost:8765',
    playerId: null,
    playerName: 'Jogador' + Math.floor(Math.random() * 1000),
    otherPlayers: new Map(),
    lastPositionSent: 0,
    positionUpdateInterval: 50 // ms
  };

  // Sistema de Controles Mobile
  const mobileControls = {
    enabled: false,
    joystick: { active: false, x: 0, y: 0 },
    look: { active: false, startX: 0, startY: 0 },
    buttons: {
      jump: false,
      fly: false,
      sprint: false,
      break: false,
      place: false
    }
  };



  const gameSettings = {
    graphics: {
      renderDistance: 6,
      antialiasing: false,
      shadows: true,
      fog: true,
      particles: 'all',
      fpsLimit: 'unlimited'
    },
    gameplay: {
      difficulty: 'normal',
      creative: false,
      autoJump: false,
      mobSpawn: 50,
      healthRegen: 5
    },
    controls: {
      mouseSensitivity: 10,
      invertY: false,
      touchSensitivity: 10
    },
    audio: {
      masterVolume: 70,
      sfxVolume: 80,
      musicVolume: 50,
      ambientVolume: 60
    }
  };




  // Adicionar os novos tipos ao enemyTypes (assumindo que este objeto existe)
  const enemyTypes = {
    zombie: {
      health: 20,
      speed: 0.03,
      damage: 3,
      attackRange: 2,
      detectionRange: 16,
      color: 0x00AA00,
      drops: ['rotten_flesh'],
      dropCount: { min: 0, max: 2 }
    },
    skeleton: {
      health: 20,
      speed: 0.04,
      damage: 2,
      attackRange: 12,
      detectionRange: 20,
      color: 0xC0C0C0,
      drops: ['bone', 'arrow'],
      dropCount: { min: 0, max: 2 }
    },
    creeper: {
      health: 20,
      speed: 0.035,
      damage: 25,
      attackRange: 3,
      detectionRange: 12,
      explodeTime: 1500,
      color: 0x00AA00,
      drops: ['gunpowder'],
      dropCount: { min: 0, max: 2 }
    },
    spider: {
      health: 16,
      speed: 0.05,
      damage: 2,
      attackRange: 2,
      detectionRange: 20,
      color: 0x4A4A4A,
      drops: ['string', 'spider_eye'],
      dropCount: { min: 0, max: 2 }
    },
    // NOVOS INIMIGOS
    enderman: {
      health: 40,
      speed: 0.07,
      damage: 7,
      attackRange: 3,
      detectionRange: 32,
      color: 0x161616,
      drops: ['ender_pearl'],
      dropCount: { min: 0, max: 1 }
    },
    ghast: {
      health: 10,
      speed: 0.02,
      damage: 6,
      attackRange: 30,
      detectionRange: 40,
      color: 0xF8F8FF,
      drops: ['ghast_tear', 'gunpowder'],
      dropCount: { min: 0, max: 1 }
    },
    slime: {
      health: 20,
      speed: 0.04,
      damage: 3,
      attackRange: 2,
      detectionRange: 12,
      color: 0x7CFC00,
      drops: ['slime_ball'],
      dropCount: { min: 0, max: 2 }
    },
    witch: {
      health: 26,
      speed: 0.03,
      damage: 4,
      attackRange: 15,
      detectionRange: 20,
      color: 0x800080,
      drops: ['glowstone_dust', 'redstone', 'sugar', 'glass_bottle'],
      dropCount: { min: 1, max: 3 }
    }
  };



  // Adicionar ap√≥s a declara√ß√£o das vari√°veis globais
  const LOD_SYSTEM = {
    enabled: true,
    distances: [20, 40, 60], // Dist√¢ncias para cada n√≠vel de LOD
    currentLOD: new Map(),
    chunkLODCache: new Map()
  };

  function getLODLevel(distance) {
    if (distance < LOD_SYSTEM.distances[0]) return 0; // Full detail
    if (distance < LOD_SYSTEM.distances[1]) return 1; // Medium detail
    if (distance < LOD_SYSTEM.distances[2]) return 2; // Low detail
    return 3; // Minimal detail
  }

  // Substituir a fun√ß√£o buildChunkMesh com suporte a LOD
  function buildChunkMeshWithLOD(cx, cz, lodLevel = 0) {
    const chunkKey = getChunkKey(cx, cz);
    const lodKey = `${chunkKey}_lod${lodLevel}`;

    // Cache de LOD
    if (LOD_SYSTEM.chunkLODCache.has(lodKey)) {
      return LOD_SYSTEM.chunkLODCache.get(lodKey);
    }

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;
    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        vertexCount: 0
      };
    }

    // Reduzir resolu√ß√£o baseado no LOD
    const step = lodLevel === 0 ? 1 : lodLevel === 1 ? 2 : lodLevel === 2 ? 4 : 8;

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx += step) {
      for (let lz = 0; lz < CHUNK_SIZE; lz += step) {
        for (let y = 0; y < 40; y += step) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];
          const blockSize = step; // Blocos maiores para LOD baixo

          const faces = [
            { dir: [1, 0, 0], corners: [[blockSize, 0, 0], [blockSize, blockSize, 0], [blockSize, blockSize, blockSize], [blockSize, 0, blockSize]] },
            { dir: [-1, 0, 0], corners: [[0, 0, blockSize], [0, blockSize, blockSize], [0, blockSize, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, blockSize, 0], [0, blockSize, blockSize], [blockSize, blockSize, blockSize], [blockSize, blockSize, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [blockSize, 0, 0], [blockSize, 0, blockSize], [0, 0, blockSize]] },
            { dir: [0, 0, 1], corners: [[0, 0, blockSize], [blockSize, 0, blockSize], [blockSize, blockSize, blockSize], [0, blockSize, blockSize]] },
            { dir: [0, 0, -1], corners: [[blockSize, 0, 0], [0, 0, 0], [0, blockSize, 0], [blockSize, blockSize, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx * step, y + dy * step, z + dz * step);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - blockSize/2,
                        y + corner[1] - blockSize/2,
                        z + corner[2] - blockSize/2
                );
                geo.normals.push(dx, dy, dz);
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];
      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setIndex(geo.indices);

      const mesh = new THREE.Mesh(geometry, materials[type]);
      mesh.userData.chunkKey = chunkKey;
      mesh.userData.type = type;
      mesh.userData.lodLevel = lodLevel;
      group.add(mesh);
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
      chunkMeshes[chunkKey].userData.lodLevel = lodLevel;

      LOD_SYSTEM.chunkLODCache.set(lodKey, group);
      enableShadowsForChunk(chunkKey);
    }

    return totalFaces;
  }


  // Adicionar ap√≥s as vari√°veis globais
  const OCCLUSION_SYSTEM = {
    enabled: true,
    checkInterval: 100, // ms
    lastCheck: 0,
    occludedChunks: new Set(),
    raycaster: new THREE.Raycaster()
  };

  function checkChunkOcclusion(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    const chunkMesh = chunkMeshes[chunkKey];

    if (!chunkMesh) return false;

    // Centro do chunk
    const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
    const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;
    const chunkCenterY = 20; // Altura m√©dia

    // Dire√ß√£o da c√¢mera para o chunk
    const direction = new THREE.Vector3(
            chunkCenterX - camera.position.x,
            chunkCenterY - camera.position.y,
            chunkCenterZ - camera.position.z
    ).normalize();

    OCCLUSION_SYSTEM.raycaster.set(camera.position, direction);

    // Verificar se h√° chunks bloqueando a vis√£o
    const allMeshes = [];
    for (let key in chunkMeshes) {
      if (key !== chunkKey) {
        allMeshes.push(...chunkMeshes[key].children);
      }
    }

    const intersects = OCCLUSION_SYSTEM.raycaster.intersectObjects(allMeshes, false);

    // Se houver intersec√ß√£o antes do chunk alvo, est√° ocluso
    if (intersects.length > 0) {
      const distanceToChunk = camera.position.distanceTo(
              new THREE.Vector3(chunkCenterX, chunkCenterY, chunkCenterZ)
      );

      return intersects[0].distance < distanceToChunk - CHUNK_SIZE;
    }

    return false;
  }

  function updateOcclusionCulling() {
    const now = Date.now();

    if (!OCCLUSION_SYSTEM.enabled || now - OCCLUSION_SYSTEM.lastCheck < OCCLUSION_SYSTEM.checkInterval) {
      return;
    }

    OCCLUSION_SYSTEM.lastCheck = now;
    OCCLUSION_SYSTEM.occludedChunks.clear();

    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);

      if (checkChunkOcclusion(cx, cz)) {
        OCCLUSION_SYSTEM.occludedChunks.add(key);
        chunkMeshes[key].visible = false;
      } else if (chunkMeshes[key].visible === false) {
        chunkMeshes[key].visible = true;
      }
    }
  }



  // Sistema de instancing para performance
  const INSTANCING_SYSTEM = {
    enabled: true,
    instances: new Map(),
    maxInstancesPerType: 1000
  };

  function createInstancedChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    // Agrupar blocos por tipo
    const blocksByType = {};

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          if (!blocksByType[block.type]) {
            blocksByType[block.type] = [];
          }

          blocksByType[block.type].push({ x, y, z });
        }
      }
    }

    const group = new THREE.Group();

    for (let type in blocksByType) {
      const blocks = blocksByType[type];

      if (blocks.length > 50) { // Usar instancing apenas se houver muitos blocos
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const mesh = new THREE.InstancedMesh(
                geometry,
                materials[type],
                Math.min(blocks.length, INSTANCING_SYSTEM.maxInstancesPerType)
        );

        const matrix = new THREE.Matrix4();

        blocks.forEach((block, i) => {
          if (i >= INSTANCING_SYSTEM.maxInstancesPerType) return;

          matrix.setPosition(block.x, block.y, block.z);
          mesh.setMatrixAt(i, matrix);
        });

        mesh.instanceMatrix.needsUpdate = true;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        group.add(mesh);
      }
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
    }
  }



















































  function createHealthUI() {
    const container = document.getElementById('health-container');
    for (let i = 0; i < MAX_HEALTH / 2; i++) {
      const heart = document.createElement('div');
      heart.className = 'heart';
      container.appendChild(heart);
    }
    updateHealthUI();
  }

  function updateHealthUI() {
    const hearts = document.querySelectorAll('.heart');
    hearts.forEach((heart, index) => {
      const heartIndex = index * 2;
      if (playerHealth >= heartIndex + 2) {
        heart.className = 'heart';
      } else if (playerHealth >= heartIndex + 1) {
        heart.className = 'heart half';
      } else {
        heart.className = 'heart empty';
      }
    });
  }

  function damagePlayer(amount) {
    playerHealth = Math.max(0, playerHealth - amount);
    updateHealthUI();

    // Verificar morte
    if (playerHealth <= 0) {
      playerHealth = MAX_HEALTH;
      camera.position.set(0, 25, 0);
      player.velocity.set(0, 0, 0);
      updateHealthUI();
    }
  }

  function initializeInventory() {
    // Blocos b√°sicos
    addToInventory('grass', 64);
    addToInventory('dirt', 64);
    addToInventory('stone', 32);
    addToInventory('wood', 32);
    addToInventory('planks', 32);

    // Blocos decorativos
    addToInventory('concrete_white', 16);
    addToInventory('concrete_blue', 16);
    addToInventory('brick', 16);
    addToInventory('quartz', 16);

    // Blocos luminosos
    addToInventory('glowstone', 16);
    addToInventory('lantern', 16);
    addToInventory('torch', 32);

    // Blocos funcionais
    addToInventory('crafting_table', 4);
    addToInventory('chest', 4);
    addToInventory('furnace', 2);

    player.selectedSlot = 0;
  }

  function addToInventory(type, count) {
    // Encontrar slot existente com o mesmo tipo
    for (let i = 0; i < player.inventory.length; i++) {
      if (player.inventory[i].type === type && player.inventory[i].count < 64) {
        const availableSpace = 64 - player.inventory[i].count;
        const toAdd = Math.min(count, availableSpace);
        player.inventory[i].count += toAdd;
        count -= toAdd;
        if (count <= 0) break;
      }
    }

    // Se ainda h√° itens, encontrar slot vazio
    if (count > 0) {
      for (let i = 0; i < player.inventory.length; i++) {
        if (player.inventory[i].count === 0) {
          player.inventory[i].type = type;
          player.inventory[i].count = Math.min(count, 64);
          count -= player.inventory[i].count;
          if (count <= 0) break;
        }
      }
    }

    updateInventoryUI();
    updateFullInventoryUI();
  }

  function removeFromInventory(slotIndex, count = 1) {
    if (slotIndex < 0 || slotIndex >= player.inventory.length) return false;
    if (player.inventory[slotIndex].count >= count) {
      player.inventory[slotIndex].count -= count;
      if (player.inventory[slotIndex].count <= 0) {
        player.inventory[slotIndex].type = null;
        player.inventory[slotIndex].count = 0;
      }
      updateInventoryUI();
      updateFullInventoryUI();
      return true;
    }
    return false;
  }

  function getSelectedItem() {
    const slot = player.inventory[player.selectedSlot];
    return slot.count > 0 ? slot.type : null;
  }

  function createInventoryUI() {
    const invBar = document.getElementById('inventory-bar');
    invBar.innerHTML = '';

    for (let i = 0; i < player.hotbarSlots; i++) {
      const slot = document.createElement('div');
      slot.className = `inv-slot ${i === player.selectedSlot ? 'active' : ''}`;
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      }

      slot.onclick = () => selectSlot(i);
      invBar.appendChild(slot);
    }
  }

  function createFullInventoryUI() {
    const invFull = document.getElementById('inventory-full');
    invFull.innerHTML = '';

    for (let i = 0; i < player.inventorySlots; i++) {
      const slot = document.createElement('div');
      slot.className = 'inv-full-slot';
      slot.dataset.index = i;

      const slotData = player.inventory[i];
      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      }

      invFull.appendChild(slot);
    }
  }

  function updateInventoryUI() {
    const slots = document.querySelectorAll('#inventory-bar .inv-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.classList.toggle('active', i === player.selectedSlot);

      if (slotData.count > 0) {
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div class="block-icon" style="background: #${colorHex}"></div>
                    <div class="slot-count">${slotData.count}</div>
                `;
      } else {
        slot.innerHTML = '';
      }
    });

    const selectedItem = getSelectedItem();
    document.getElementById('selected-block').textContent = selectedItem ? itemTypes[selectedItem].name : 'Vazio';
  }

  function updateFullInventoryUI() {
    const slots = document.querySelectorAll('#inventory-full .inv-full-slot');
    slots.forEach((slot, i) => {
      const slotData = player.inventory[i];
      slot.innerHTML = '';

      if (slotData.count > 0) {
        slot.classList.add('has-item');
        const colorHex = itemTypes[slotData.type].color.toString(16).padStart(6, '0');
        slot.innerHTML = `
                    <div style="width: 35px; height: 35px; background: #${colorHex}; border-radius: 3px;"></div>
                    <div style="position: absolute; bottom: 2px; right: 5px; font-size: 10px; color: white;">${slotData.count}</div>
                `;
      } else {
        slot.classList.remove('has-item');
      }
    });
  }

  function selectSlot(index) {
    if (index >= 0 && index < player.hotbarSlots) {
      player.selectedSlot = index;
      updateInventoryUI();
    }
  }

  function toggleFullInventory() {
    const invFull = document.getElementById('inventory-full');
    invFull.classList.toggle('open');
    controls.locked = !invFull.classList.contains('open');

    if (invFull.classList.contains('open')) {
      document.exitPointerLock();
      updateFullInventoryUI();
    } else {
      renderer.domElement.requestPointerLock();
    }
  }

  function getHeight(x, z) {
    const n1 = noise(x * 0.04, z * 0.04) * 10;
    const n2 = noise(x * 0.08, z * 0.08) * 5;
    const n3 = noise(x * 0.15, z * 0.15) * 2;
    return Math.floor(12 + n1 + n2 + n3);
  }

  function getBlockKey(x, y, z) {
    return `${x},${y},${z}`;
  }

  function getChunkKey(cx, cz) {
    return `${cx},${cz}`;
  }

  function worldToChunk(x, z) {
    return {
      x: Math.floor(x / CHUNK_SIZE),
      z: Math.floor(z / CHUNK_SIZE)
    };
  }

  function setBlock(x, y, z, type) {
    worldData[getBlockKey(x, y, z)] = { x, y, z, type };
  }

  function getBlock(x, y, z) {
    return worldData[getBlockKey(x, y, z)];
  }

  function removeBlockData(x, y, z) {
    delete worldData[getBlockKey(x, y, z)];
  }

  function removeAnimalsInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = animals.length - 1; i >= 0; i--) {
      const animal = animals[i];
      if (animal.x >= sx && animal.x < ex && animal.z >= sz && animal.z < ez) {
        animal.remove();
        animals.splice(i, 1);
      }
    }
  }

  function buildChunkMesh(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);

    if (chunkMeshes[chunkKey]) {
      scene.remove(chunkMeshes[chunkKey]);
      chunkMeshes[chunkKey].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[chunkKey];
    }

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    const geometriesByType = {};

    for (let type in blockTypes) {
      geometriesByType[type] = {
        positions: [],
        normals: [],
        indices: [],
        vertexCount: 0
      };
    }

    let totalFaces = 0;

    for (let lx = 0; lx < CHUNK_SIZE; lx++) {
      for (let lz = 0; lz < CHUNK_SIZE; lz++) {
        for (let y = 0; y < 40; y++) {
          const x = sx + lx;
          const z = sz + lz;
          const block = getBlock(x, y, z);

          if (!block) continue;

          const geo = geometriesByType[block.type];

          const faces = [
            { dir: [1, 0, 0], corners: [[1, 0, 0], [1, 1, 0], [1, 1, 1], [1, 0, 1]] },
            { dir: [-1, 0, 0], corners: [[0, 0, 1], [0, 1, 1], [0, 1, 0], [0, 0, 0]] },
            { dir: [0, 1, 0], corners: [[0, 1, 0], [0, 1, 1], [1, 1, 1], [1, 1, 0]] },
            { dir: [0, -1, 0], corners: [[0, 0, 0], [1, 0, 0], [1, 0, 1], [0, 0, 1]] },
            { dir: [0, 0, 1], corners: [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]] },
            { dir: [0, 0, -1], corners: [[1, 0, 0], [0, 0, 0], [0, 1, 0], [1, 1, 0]] }
          ];

          for (let face of faces) {
            const [dx, dy, dz] = face.dir;
            const neighbor = getBlock(x + dx, y + dy, z + dz);

            if (!neighbor) {
              const baseIdx = geo.vertexCount;

              for (let corner of face.corners) {
                geo.positions.push(
                        x + corner[0] - 0.5,
                        y + corner[1] - 0.5,
                        z + corner[2] - 0.5
                );
                geo.normals.push(dx, dy, dz);
              }

              geo.indices.push(
                      baseIdx, baseIdx + 1, baseIdx + 2,
                      baseIdx, baseIdx + 2, baseIdx + 3
              );

              geo.vertexCount += 4;
              totalFaces++;
            }
          }
        }
      }
    }

    const group = new THREE.Group();

    for (let type in geometriesByType) {
      const geo = geometriesByType[type];

      if (geo.positions.length === 0) continue;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(geo.positions, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(geo.normals, 3));
      geometry.setIndex(geo.indices);

      const mesh = new THREE.Mesh(geometry, materials[type]);
      mesh.userData.chunkKey = chunkKey;
      mesh.userData.type = type;
      group.add(mesh);
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;
    }

    if (group.children.length > 0) {
      scene.add(group);
      chunkMeshes[chunkKey] = group;
      chunkMeshes[chunkKey].userData.faceCount = totalFaces;

      // ‚ú® ATIVAR SOMBRAS PARA O CHUNK
      enableShadowsForChunk(chunkKey);
    }


    return totalFaces;
  }

  function removeEnemiesInChunk(chunkX, chunkZ) {
    const sx = chunkX * CHUNK_SIZE;
    const sz = chunkZ * CHUNK_SIZE;
    const ex = sx + CHUNK_SIZE;
    const ez = sz + CHUNK_SIZE;

    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      if (enemy.x >= sx && enemy.x < ex && enemy.z >= sz && enemy.z < ez) {
        enemy.remove();
        enemies.splice(i, 1);
      }
    }
  }

  function updateFaceCount() {
    let totalFaces = 0;
    for (let key in chunkMeshes) {
      if (chunkMeshes[key].userData.faceCount) {
        totalFaces += chunkMeshes[key].userData.faceCount;
      }
    }
    document.getElementById('visible').textContent = totalFaces;
  }

  function updateBreakAnimations() {
    const now = Date.now();
    breakingAnimations = breakingAnimations.filter(anim => {
      const age = now - anim.created;
      if (age > 400) {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
        return false;
      }

      anim.particles.forEach(p => {
        p.velocity.y -= 0.01;
        p.position.add(p.velocity);
        p.material.opacity = 1 - (age / 400);
      });

      return true;
    });
  }

  function setupEventListeners() {
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // Selecionar slots 1-9
      if (e.code >= 'Digit1' && e.code <= 'Digit9') {
        const idx = parseInt(e.code.slice(-1)) - 1;
        if (idx < player.hotbarSlots) selectSlot(idx);
      }

      // Modo voo
      if (e.code === 'KeyF') {
        player.flying = !player.flying;
        document.getElementById('mode').textContent = player.flying ? 'Voo' : 'Normal';
      }

      // Invent√°rio completo
      if (e.code === 'KeyE') {
        toggleFullInventory();
      }

      // Jogar item
      if (e.code === 'KeyQ' && !document.getElementById('inventory-full').classList.contains('open')) {
        const selectedItem = getSelectedItem();
        if (selectedItem && removeFromInventory(player.selectedSlot, 1)) {
          // Criar entidade do item jogado
          const itemMesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.3, 0.3, 0.3),
                  new THREE.MeshLambertMaterial({ color: itemTypes[selectedItem].color })
          );
          itemMesh.position.copy(camera.position);
          itemMesh.velocity = new THREE.Vector3(
                  camera.getWorldDirection(new THREE.Vector3()).x * 0.5,
                  0.3,
                  camera.getWorldDirection(new THREE.Vector3()).z * 0.5
          );
          scene.add(itemMesh);

          // Remover ap√≥s 5 segundos
          setTimeout(() => {
            if (itemMesh.parent) {
              scene.remove(itemMesh);
            }
          }, 5000);
        }
      }

      // Reproduzir animais (debug)
      if (e.code === 'KeyR') {
        const chunk = worldToChunk(camera.position.x, camera.position.z);
        spawnAnimals(chunk.x, chunk.z);
      }
    });

    document.addEventListener('keyup', (e) => keys[e.code] = false);

    document.addEventListener('mousemove', (e) => {
      if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

      // Corre√ß√£o: Controles desinvertidos - movimento do mouse mais suave
      mouse.x -= e.movementX * 0.002; // Invertido o sinal para desinverter
      mouse.y -= e.movementY * 0.002; // Mantido para controle vertical normal

      mouse.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouse.y));
    });

    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);
    document.addEventListener('wheel', handleScroll);
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    window.addEventListener('resize', onWindowResize);

    document.addEventListener('pointerlockchange', () => {
      controls.locked = document.pointerLockElement === renderer.domElement;
    });
  }

  function handleInventoryScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    if (mobileControls.enabled) return; // Desabilitar scroll em mobile

    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  document.addEventListener('wheel', handleInventoryScroll);

  function handleMouseDown(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar colis√£o com animais primeiro
    const animalIntersects = raycaster.intersectObjects(animalMeshes);
    if (animalIntersects.length > 0 && e.button === 0) {
      const animalMesh = animalIntersects[0].object;
      const animal = animals.find(a => a.mesh === animalMesh);
      if (animal) {
        if (animal.damage(1)) {
          // Animal morto
          damagePlayer(1); // Dano ao jogador por matar animal
        }
      }
      return;
    }

    // Verificar colis√£o com blocos
    const allMeshes = [];
    for (let key in chunkMeshes) {
      allMeshes.push(...chunkMeshes[key].children);
    }

    const intersects = raycaster.intersectObjects(allMeshes);
    if (intersects.length === 0) return;

    const hit = intersects[0];
    const hitPos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(-0.1));
    const bx = Math.round(hitPos.x);
    const by = Math.round(hitPos.y);
    const bz = Math.round(hitPos.z);

    if (e.button === 0) {
      const block = getBlock(bx, by, bz);
      if (block && block.type !== 'bedrock') {
        player.breaking = { x: bx, y: by, z: bz };
        player.breakStartTime = Date.now();
        player.breakBlockType = block.type;

        // Mostrar barra de progresso
        const progressBar = document.getElementById('break-progress');
        progressBar.style.display = 'block';
      }
    } else if (e.button === 2) {
      const placePos = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
      const px = Math.round(placePos.x);
      const py = Math.round(placePos.y);
      const pz = Math.round(placePos.z);

      const selectedItem = getSelectedItem();
      if (selectedItem && blockTypes[selectedItem]) {
        placeBlock(px, py, pz, selectedItem);
      }
    }
  }

  function handleMouseUp(e) {
    if (e.button === 0) {
      player.breaking = null;
      player.breakProgress = 0;
      document.getElementById('break-progress').style.display = 'none';
    }
  }

  function updateBreaking() {
    if (player.breaking) {
      const block = getBlock(player.breaking.x, player.breaking.y, player.breaking.z);
      if (!block || block.type !== player.breakBlockType) {
        player.breaking = null;
        document.getElementById('break-progress').style.display = 'none';
        return;
      }

      const hardness = blockTypes[block.type].hardness;
      const elapsed = Date.now() - player.breakStartTime;
      player.breakProgress = elapsed / (BREAK_TIME * hardness);

      // Atualizar barra de progresso
      const progressFill = document.querySelector('.break-progress-fill');
      progressFill.style.width = `${Math.min(player.breakProgress * 100, 100)}%`;

      if (player.breakProgress >= 1) {
        removeBlock(player.breaking.x, player.breaking.y, player.breaking.z);
        player.breaking = null;
        player.breakProgress = 0;
        document.getElementById('break-progress').style.display = 'none';
      }
    }
  }

  function handleScroll(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;
    e.preventDefault();
    const dir = e.deltaY > 0 ? 1 : -1;
    const newSlot = (player.selectedSlot + dir + player.hotbarSlots) % player.hotbarSlots;
    selectSlot(newSlot);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function updatePlayer() {
    const dir = new THREE.Vector3();
    const right = new THREE.Vector3();

    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();
    // CORRE√á√ÉO: Vetor right calculado corretamente para controles padr√£o
    right.crossVectors(dir, camera.up).normalize();

    const speed = keys['ShiftLeft'] ? SPRINT_SPEED : (player.flying ? FLY_SPEED : MOVE_SPEED);

    // Calcular movimento desejado - CORRE√á√ÉO DOS CONTROLES
    const move = new THREE.Vector3();
    if (keys['KeyW']) move.add(dir);
    if (keys['KeyS']) move.add(dir.clone().negate());
    if (keys['KeyA']) move.add(right.clone().negate()); // CORRE√á√ÉO: Movimento para esquerda
    if (keys['KeyD']) move.add(right); // CORRE√á√ÉO: Movimento para direita

    if (move.length() > 0) {
      move.normalize().multiplyScalar(speed);
    }

    // Aplicar gravidade se n√£o estiver voando
    if (!player.flying) {
      player.velocity.y += GRAVITY;
      move.y = player.velocity.y;
    } else {
      if (keys['Space']) move.y = FLY_SPEED;
      if (keys['ShiftLeft']) move.y = -FLY_SPEED;
      player.velocity.y = 0;
    }

    // Detectar colis√µes e ajustar movimento
    const newPos = camera.position.clone().add(move);
    const collision = checkCollision(newPos);

    // Colis√£o lateral
    if (collision.sides) {
      // Projetar movimento no plano XZ para evitar paredes
      const lateralMove = new THREE.Vector3(move.x, 0, move.z);

      // Testar movimento apenas em X
      const testX = new THREE.Vector3(camera.position.x + move.x, camera.position.y, camera.position.z);
      if (!checkCollision(testX).sides) {
        camera.position.x = testX.x;
        move.x = 0;
      }

      // Testar movimento apenas em Z
      const testZ = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z + move.z);
      if (!checkCollision(testZ).sides) {
        camera.position.z = testZ.z;
        move.z = 0;
      }

      // Se ainda houver colis√£o, tentar deslizar
      if (move.x !== 0 || move.z !== 0) {
        const slideMove = new THREE.Vector3(move.x, 0, move.z);
        slideMove.normalize().multiplyScalar(speed * 0.5);

        const testSlide = new THREE.Vector3(
                camera.position.x + slideMove.x,
                camera.position.y,
                camera.position.z + slideMove.z
        );

        if (!checkCollision(testSlide).sides) {
          camera.position.x = testSlide.x;
          camera.position.z = testSlide.z;
        }
      }
    } else {
      // Sem colis√£o lateral, mover normalmente
      camera.position.x += move.x;
      camera.position.z += move.z;
    }

    // Colis√£o vertical
    if (collision.ground) {
      // No ch√£o
      player.velocity.y = 0;
      player.canJump = true;

      // Ajustar posi√ß√£o para ficar exatamente em cima do bloco
      const groundY = Math.floor(newPos.y - PLAYER_HEIGHT/2) + 1 + PLAYER_HEIGHT/2;
      camera.position.y = groundY;

      // Pular
      if (keys['Space'] && player.canJump) {
        player.velocity.y = JUMP_SPEED;
        player.canJump = false;
      }
    } else if (collision.ceiling) {
      // Batendo no teto
      player.velocity.y = Math.min(player.velocity.y, 0);
      const ceilingY = Math.floor(newPos.y + PLAYER_HEIGHT/2) - COLLISION_TOLERANCE - PLAYER_HEIGHT/2;
      camera.position.y = ceilingY;
    } else {
      // No ar
      camera.position.y += move.y;
      player.canJump = false;
    }

    // Dano por queda
    if (player.velocity.y < -2.5 && !player.flying && collision.ground) {
      const fallDamage = Math.floor(Math.abs(player.velocity.y) - 2);
      if (fallDamage > 0) {
        damagePlayer(fallDamage);
      }
    }

    // Atualizar rota√ß√£o da c√¢mera
    camera.rotation.order = 'YXZ';
    camera.rotation.y = mouse.x;
    camera.rotation.x = mouse.y;

    // Atualizar chunks
    const chunk = worldToChunk(camera.position.x, camera.position.z);
    if (chunk.x !== player.lastChunk.x || chunk.z !== player.lastChunk.z) {
      player.lastChunk = chunk;
      updateVisibleChunks();
    }
  }

  function checkCollision(position) {
    const result = {
      sides: false,
      ground: false,
      ceiling: false
    };

    // Definir pontos de teste para o jogador
    const playerMinY = position.y - PLAYER_HEIGHT/2;
    const playerMaxY = position.y + PLAYER_HEIGHT/2;
    const playerRadius = PLAYER_WIDTH/2;

    // Testar colis√£o com o ch√£o
    const groundTestPoints = [
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMinY - COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMinY - COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of groundTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ground = true;
        break;
      }
    }

    // Testar colis√£o com o teto
    const ceilingTestPoints = [
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x + playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x - playerRadius, playerMaxY + COLLISION_TOLERANCE, position.z),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z + playerRadius),
      new THREE.Vector3(position.x, playerMaxY + COLLISION_TOLERANCE, position.z - playerRadius)
    ];

    for (const point of ceilingTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.ceiling = true;
        break;
      }
    }

    // Testar colis√£o lateral
    const sideTestPoints = [];
    const angles = [0, 45, 90, 135, 180, 225, 270, 315];

    for (const angle of angles) {
      const rad = angle * Math.PI / 180;
      const testPoint = new THREE.Vector3(
              position.x + Math.cos(rad) * playerRadius,
              position.y,
              position.z + Math.sin(rad) * playerRadius
      );
      sideTestPoints.push(testPoint);

      // Testar tamb√©m em diferentes alturas
      sideTestPoints.push(testPoint.clone().setY(position.y + PLAYER_HEIGHT/3));
      sideTestPoints.push(testPoint.clone().setY(position.y - PLAYER_HEIGHT/3));
    }

    for (const point of sideTestPoints) {
      const block = getBlock(
              Math.floor(point.x),
              Math.floor(point.y),
              Math.floor(point.z)
      );
      if (block && block.type !== 'leaves' && block.type !== 'glass') {
        result.sides = true;
        break;
      }
    }

    return result;
  }

  function noise(x, z) {
    const X = Math.floor(x);
    const Z = Math.floor(z);
    const xf = x - X;
    const zf = z - Z;

    const a = hash(X, Z);
    const b = hash(X + 1, Z);
    const c = hash(X, Z + 1);
    const d = hash(X + 1, Z + 1);

    const u = xf * xf * (3.0 - 2.0 * xf);
    const v = zf * zf * (3.0 - 2.0 * zf);

    return a * (1 - u) * (1 - v) + b * u * (1 - v) + c * (1 - u) * v + d * u * v;
  }

  function hash(x, y) {
    let h = x * 374761393 + y * 668265263;
    h = (h ^ (h >> 13)) * 1274126177;
    return Math.abs((h ^ (h >> 16)) / 2147483648.0);
  }

  function createPlayerModel() {
    const group = new THREE.Group();

    // Corpo
    const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.3);
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = -0.8;
    group.add(body);

    // Cabe√ßa
    const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xFFDBAC });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = -0.1;
    head.userData.isHead = true;
    group.add(head);

    // Bra√ßos
    const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
    const armMat = new THREE.MeshLambertMaterial({ color: 0x4169E1 });

    const leftArm = new THREE.Mesh(armGeo, armMat);
    leftArm.position.set(-0.4, -0.7, 0);
    leftArm.userData.isArm = true;
    leftArm.userData.side = 'left';
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, armMat);
    rightArm.position.set(0.4, -0.7, 0);
    rightArm.userData.isArm = true;
    rightArm.userData.side = 'right';
    group.add(rightArm);

    // Pernas
    const legGeo = new THREE.BoxGeometry(0.25, 0.9, 0.25);
    const legMat = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });

    const leftLeg = new THREE.Mesh(legGeo, legMat);
    leftLeg.position.set(-0.15, -1.4, 0);
    leftLeg.userData.isLeg = true;
    leftLeg.userData.side = 'left';
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, legMat);
    rightLeg.position.set(0.15, -1.4, 0);
    rightLeg.userData.isLeg = true;
    rightLeg.userData.side = 'right';
    group.add(rightLeg);

    playerModel = group;
    camera.add(playerModel);
  }

  const originalHandleMouseDown = handleMouseDown;

  handleMouseDown = function(e) {
    if (!controls.locked || document.getElementById('inventory-full').classList.contains('open')) return;

    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Verificar inimigos primeiro
    if (e.button === 0) {
      const enemyIntersects = raycaster.intersectObjects(enemyMeshes);
      if (enemyIntersects.length > 0) {
        const enemyMesh = enemyIntersects[0].object;
        let enemy = null;

        // Encontrar o grupo pai que cont√©m a refer√™ncia ao inimigo
        let current = enemyMesh;
        while (current && !enemy) {
          if (current.userData && current.userData.enemyRef) {
            enemy = current.userData.enemyRef;
          }
          current = current.parent;
        }

        if (enemy) {
          enemy.damage(5);
          return;
        }
      }
    }

    // Chamar fun√ß√£o original para blocos e animais
    originalHandleMouseDown.call(this, e);
  };

  const originalStartGame = startGame;
  startGame = function() {
    originalStartGame.call(this);


    createPlayerModel();

    // Gerar uma vila pr√≥xima ao spawn
    generateVillage(30, 30);

    // Spawnar alguns inimigos
    const chunk = worldToChunk(0, 0);
    for (let cx = chunk.x - 2; cx <= chunk.x + 2; cx++) {
      for (let cz = chunk.z - 2; cz <= chunk.z + 2; cz++) {
        if (Math.random() > 0.7) {
          spawnEnemies(cx, cz);
        }
      }
    }

    initMobileControls();
    animate();
  };

  // Atualizar UI para mostrar contagem de entidades
  document.getElementById('animals-count').parentElement.querySelector('strong').textContent = 'Entidades:';


  let sky, waterMeshes = [], particles = [], clouds = [];
  let dayNightCycle = 0;
  const DAY_LENGTH = 120000;

  let playerCharacter = null;

  class WaterSystem {
    constructor() {
      this.meshes = [];
      this.waterLevels = new Map();
    }

    createWaterBlock(x, y, z) {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshLambertMaterial({
        color: 0x1E90FF,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });

      const water = new THREE.Mesh(geometry, material);
      water.position.set(x, y, z);
      water.userData.isWater = true;
      water.userData.waveOffset = Math.random() * Math.PI * 2;
      water.userData.baseY = y;

      scene.add(water);
      this.meshes.push(water);
      waterMeshes.push(water);

      return water;
    }

    updateWaves(time) {
      for (const water of this.meshes) {
        if (water.userData.isWater) {
          const waveHeight = Math.sin(time * 2 + water.userData.waveOffset) * 0.05;
          water.position.y = water.userData.baseY + waveHeight;

          // Efeito de transpar√™ncia pulsante
          water.material.opacity = 0.6 + Math.sin(time * 3 + water.userData.waveOffset) * 0.1;
        }
      }
    }

    removeWater(x, y, z) {
      for (let i = this.meshes.length - 1; i >= 0; i--) {
        const water = this.meshes[i];
        if (Math.floor(water.position.x) === x &&
                Math.floor(water.position.y) === y &&
                Math.floor(water.position.z) === z) {
          scene.remove(water);
          water.geometry.dispose();
          water.material.dispose();
          this.meshes.splice(i, 1);

          const waterIndex = waterMeshes.indexOf(water);
          if (waterIndex > -1) waterMeshes.splice(waterIndex, 1);
          break;
        }
      }
    }
  }

  let waterSystem = null;

  class ParticleSystem {
    constructor() {
      this.particles = [];
      this.maxParticles = 1000;
      this.pool = [];
      this.initPool();
    }

    initPool() {
      for (let i = 0; i < this.maxParticles; i++) {
        const geometry = new THREE.SphereGeometry(0.05, 3, 3);
        const material = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const particle = new THREE.Mesh(geometry, material);
        particle.visible = false;
        scene.add(particle);
        this.pool.push(particle);
      }
    }

    emit(position, color, count = 10, velocity = 0.1) {
      for (let i = 0; i < Math.min(count, this.pool.length); i++) {
        const particle = this.pool.pop();
        if (!particle) break;

        particle.position.copy(position);
        particle.position.add(new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
        ));

        particle.material.color.set(color);
        particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * velocity,
                Math.random() * velocity * 0.5,
                (Math.random() - 0.5) * velocity
        );
        particle.userData.life = 1.0;
        particle.userData.decay = 0.02 + Math.random() * 0.02;
        particle.visible = true;

        this.particles.push(particle);
      }
    }

    update() {
      for (let i = this.particles.length - 1; i >= 0; i--) {
        const particle = this.particles[i];

        particle.userData.life -= particle.userData.decay;
        particle.position.add(particle.userData.velocity);
        particle.userData.velocity.y -= 0.01;

        particle.material.opacity = particle.userData.life;
        particle.scale.setScalar(particle.userData.life);

        if (particle.userData.life <= 0) {
          particle.visible = false;
          this.pool.push(particle);
          this.particles.splice(i, 1);
        }
      }
    }
  }

  let particleSystem = null;

  function createSky() {
    // C√©u gradient
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');

    const gradient = context.createLinearGradient(0, 0, 0, 256);
    gradient.addColorStop(0, '#87CEEB');
    gradient.addColorStop(0.5, '#98D8F0');
    gradient.addColorStop(1, '#B0E0E6');

    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);

    const texture = new THREE.CanvasTexture(canvas);
    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: texture,
      side: THREE.BackSide,
      fog: false
    });

    sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);
  }

  function createClouds() {
    const cloudCount = 30;
    for (let i = 0; i < cloudCount; i++) {
      const cloudGroup = new THREE.Group();

      // Criar nuvem com m√∫ltiplas esferas
      const cloudPieces = 3 + Math.floor(Math.random() * 3);
      for (let j = 0; j < cloudPieces; j++) {
        const size = 3 + Math.random() * 2;
        const geometry = new THREE.SphereGeometry(size, 8, 8);
        const material = new THREE.MeshLambertMaterial({
          color: 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });

        const piece = new THREE.Mesh(geometry, material);
        piece.position.set(
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 8
        );
        cloudGroup.add(piece);
      }

      // Posicionar nuvem no c√©u
      cloudGroup.position.set(
              (Math.random() - 0.5) * 400,
              80 + Math.random() * 40,
              (Math.random() - 0.5) * 400
      );

      cloudGroup.userData.speed = 0.01 + Math.random() * 0.02;
      cloudGroup.userData.direction = new THREE.Vector3(
              Math.random() - 0.5,
              0,
              Math.random() - 0.5
      ).normalize();

      scene.add(cloudGroup);
      clouds.push(cloudGroup);
    }
  }

  function updateDayNightCycle(deltaTime) {
    dayNightCycle = (dayNightCycle + deltaTime * 0.001) % 1;

    const timeOfDay = Math.sin(dayNightCycle * Math.PI * 2);
    const brightness = Math.max(0.3, timeOfDay * 0.5 + 0.5);

    // Atualizar luz ambiente
    scene.traverse(object => {
      if (object.isLight && object.type !== 'AmbientLight') {
        object.intensity = brightness;
      }
    });

    // Atualizar cor do c√©u
    if (sky && sky.material.map) {
      const canvas = sky.material.map.image;
      const context = canvas.getContext('2d');

      const dayColor = `rgb(${135 * brightness}, ${206 * brightness}, ${235 * brightness})`;
      const nightColor = `rgb(${10 * brightness}, ${10 * brightness}, ${40 * brightness})`;

      const gradient = context.createLinearGradient(0, 0, 0, 256);
      gradient.addColorStop(0, timeOfDay > 0 ? dayColor : nightColor);
      gradient.addColorStop(1, timeOfDay > 0 ?
              `rgb(${152 * brightness}, ${216 * brightness}, ${240 * brightness})` :
              `rgb(${5 * brightness}, ${5 * brightness}, ${20 * brightness})`);

      context.fillStyle = gradient;
      context.fillRect(0, 0, 256, 256);

      sky.material.map.needsUpdate = true;
    }

    // Mover nuvens
    clouds.forEach(cloud => {
      cloud.position.add(cloud.userData.direction.clone().multiplyScalar(cloud.userData.speed));

      // Reposicionar nuvens que sa√≠ram do mapa
      if (cloud.position.length() > 500) {
        cloud.position.set(
                (Math.random() - 0.5) * 400,
                80 + Math.random() * 40,
                (Math.random() - 0.5) * 400
        );
      }
    });
  }

  const textureCache = {};

  function createTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createGrassTexture(ctx, size);
        break;

      case 'dirt':
        createDirtTexture(ctx, size);
        break;

      case 'stone':
        createStoneTexture(ctx, size);
        break;

      case 'wood':
        createWoodTexture(ctx, size);
        break;

      case 'leaves':
        createLeavesTexture(ctx, size);
        break;

      case 'sand':
        createSandTexture(ctx, size);
        break;

      case 'cobblestone':
        createCobblestoneTexture(ctx, size);
        break;

      case 'planks':
        createPlanksTexture(ctx, size);
        break;

      case 'brick':
        createBrickTexture(ctx, size);
        break;

      case 'obsidian':
        createObsidianTexture(ctx, size);
        break;

      case 'glowstone':
        createGlowstoneTexture(ctx, size);
        break;

      case 'quartz':
        createQuartzTexture(ctx, size);
        break;

      case 'bookshelf':
        createBookshelfTexture(ctx, size);
        break;

      case 'coal_ore':
        createStoneTexture(ctx, size);
        // Veios de carv√£o
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(52, 52, 52, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'iron_ore':
        createStoneTexture(ctx, size);
        // Manchas de ferro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(216, 175, 147, 0.7)';
          ctx.fillRect(x, y, 8, 8);
        }
        break;

      case 'diamond_ore':
        createStoneTexture(ctx, size);
        // Cristais de diamante
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 206, 209, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho
          ctx.fillStyle = 'rgba(100, 255, 255, 0.5)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'gold_ore':
        createStoneTexture(ctx, size);
        // Veios de ouro
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.fillRect(x, y, 7, 7);
          // Brilho dourado
          ctx.fillStyle = 'rgba(255, 235, 100, 0.4)';
          ctx.fillRect(x + 1, y + 1, 3, 3);
        }
        break;

      case 'emerald_ore':
        createStoneTexture(ctx, size);
        // Cristais de esmeralda
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(80, 200, 120, 0.9)';
          ctx.fillRect(x, y, 6, 6);
          // Brilho verde
          ctx.fillStyle = 'rgba(100, 255, 150, 0.4)';
          ctx.fillRect(x + 2, y + 2, 2, 2);
        }
        break;

      case 'redstone_ore':
        createStoneTexture(ctx, size);
        // Veios de redstone
        for (let i = 0; i < 18; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillRect(x, y, 5, 5);
          // Brilho vermelho
          ctx.fillStyle = 'rgba(255, 50, 50, 0.5)';
          ctx.fillRect(x + 1, y + 1, 2, 2);
        }
        break;

      case 'lapis_ore':
        createStoneTexture(ctx, size);
        // Manchas de l√°pis-laz√∫li
        for (let i = 0; i < 16; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 255, 0.8)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      case 'gravel':
        // Base cinza
        ctx.fillStyle = '#8B8680';
        ctx.fillRect(0, 0, size, size);
        // Pedrinhas
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${139 + shade}, ${134 + shade}, ${128 + shade})`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'clay':
        // Base cinza claro
        ctx.fillStyle = '#A0A0A0';
        ctx.fillRect(0, 0, size, size);
        // Textura de argila
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${160 + shade}, ${160 + shade}, ${160 + shade})`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'ice':
        // Base azul claro
        ctx.fillStyle = '#B0E0E6';
        ctx.fillRect(0, 0, size, size);
        // Cristais de gelo
        for (let i = 0; i < 30; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 230, 240, 0.5)';
          ctx.fillRect(x, y, 4, 4);
        }
        // Brilhos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'snow':
        // Base branca
        ctx.fillStyle = '#FFFAFA';
        ctx.fillRect(0, 0, size, size);
        // Cristais de neve
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 248, 255, 0.8)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'glass':
        // Base transparente azulada
        ctx.fillStyle = '#ADD8E6';
        ctx.fillRect(0, 0, size, size);
        // Reflexos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fillRect(x, y, 6, 2);
        }
        break;

      case 'lantern':
        // Base met√°lica
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        // Grades
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        // Luz central
        const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/3);
        gradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
        gradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        break;

      case 'torch':
        // Base escura
        ctx.fillStyle = '#654321';
        ctx.fillRect(0, 0, size, size);
        // Cabo da tocha
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size/2 - 4, size/2, 8, size/2);
        // Fogo
        const torchGradient = ctx.createRadialGradient(size/2, size/3, 0, size/2, size/3, size/3);
        torchGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
        torchGradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.8)');
        torchGradient.addColorStop(1, 'rgba(255, 69, 0, 0)');
        ctx.fillStyle = torchGradient;
        ctx.beginPath();
        ctx.arc(size/2, size/3, size/3, 0, Math.PI * 2);
        ctx.fill();
        break;

      case 'prismarine':
        // Base turquesa
        ctx.fillStyle = '#4ECDC4';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o oce√¢nico
        for (let i = 0; i < size * 8; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 60 - 30;
          ctx.fillStyle = `rgba(${78 + shade}, ${205 + shade}, ${196 + shade}, 0.7)`;
          ctx.fillRect(x, y, 4, 4);
        }
        break;

      case 'purpur':
        // Base roxa
        ctx.fillStyle = '#A569BD';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o de purpur
        for (let i = 0; i < size * 6; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${165 + shade}, ${105 + shade}, ${189 + shade}, 0.8)`;
          ctx.fillRect(x, y, 5, 5);
        }
        break;

      case 'endstone':
        // Base amarelada
        ctx.fillStyle = '#E4E096';
        ctx.fillRect(0, 0, size, size);
        // Textura porosa
        for (let i = 0; i < size * 10; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${228 + shade}, ${224 + shade}, ${150 + shade}, 0.8)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'netherite':
        // Base roxa escura
        ctx.fillStyle = '#8B008B';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o met√°lico
        for (let i = 0; i < 40; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(139, 0, 139, 0.6)';
          ctx.fillRect(x, y, 6, 6);
        }
        // Brilhos met√°licos
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(200, 100, 200, 0.4)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_white':
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, size, size);
        // Textura lisa
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(240, 240, 240, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_red':
        ctx.fillStyle = '#DC143C';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${220 + shade}, ${20 + shade}, ${60 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_blue':
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${30 + shade}, ${144 + shade}, ${255 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_green':
        ctx.fillStyle = '#32CD32';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${50 + shade}, ${205 + shade}, ${50 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_yellow':
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 20 - 10;
          ctx.fillStyle = `rgba(${255 + shade}, ${215 + shade}, ${0 + shade}, 0.3)`;
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'concrete_black':
        ctx.fillStyle = '#2F4F4F';
        ctx.fillRect(0, 0, size, size);
        for (let i = 0; i < size * 4; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(40, 60, 60, 0.3)';
          ctx.fillRect(x, y, 2, 2);
        }
        break;

      case 'crafting_table':
        // Base madeira
        createPlanksTexture(ctx, size);
        // Grade de ferramentas no topo
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.strokeRect(size/4, size/4, size/2, size/2);
        ctx.beginPath();
        ctx.moveTo(size/2, size/4);
        ctx.lineTo(size/2, 3*size/4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(size/4, size/2);
        ctx.lineTo(3*size/4, size/2);
        ctx.stroke();
        break;

      case 'furnace':
        createStoneTexture(ctx, size);
        // Abertura da fornalha
        ctx.fillStyle = '#1C1C1C';
        ctx.fillRect(size/4, size/3, size/2, size/3);
        // Borda
        ctx.strokeStyle = '#4A4A4A';
        ctx.lineWidth = 3;
        ctx.strokeRect(size/4, size/3, size/2, size/3);
        break;

      case 'chest':
        createPlanksTexture(ctx, size);
        // Tranca
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(size/2 - 6, size/2 - 4, 12, 8);
        // Detalhes met√°licos
        ctx.strokeStyle = '#8B7500';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, size, size);
        ctx.beginPath();
        ctx.moveTo(0, size/2);
        ctx.lineTo(size, size/2);
        ctx.stroke();
        break;

      case 'mushroom_red':
        // Base vermelha
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(0, 0, size, size);
        // Pintas brancas
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const r = 2 + Math.random() * 4;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        break;

      case 'mushroom_brown':
        // Base marrom
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, 0, size, size);
        // Textura de cogumelo
        for (let i = 0; i < size * 5; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, 0.6)`;
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'pumpkin':
        // Base laranja
        ctx.fillStyle = '#FF8C00';
        ctx.fillRect(0, 0, size, size);
        // Gomos verticais
        ctx.strokeStyle = '#CC7000';
        ctx.lineWidth = 3;
        for (let i = 1; i < 4; i++) {
          ctx.beginPath();
          ctx.moveTo(i * size/4, 0);
          ctx.lineTo(i * size/4, size);
          ctx.stroke();
        }
        // Rosto (opcional)
        ctx.fillStyle = '#000000';
        ctx.fillRect(size/4, size/3, 8, 8);
        ctx.fillRect(3*size/4 - 8, size/3, 8, 8);
        ctx.fillRect(size/3, 2*size/3, size/3, 6);
        break;

      case 'melon':
        // Base verde clara
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(0, 0, size, size);
        // Listras verdes escuras
        ctx.strokeStyle = '#228B22';
        ctx.lineWidth = 4;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * size/4);
          ctx.lineTo(size, i * size/4);
          ctx.stroke();
        }
        break;

      case 'water':
        // Base azul
        ctx.fillStyle = '#1E90FF';
        ctx.fillRect(0, 0, size, size);
        // Ondas
        for (let i = 0; i < 10; i++) {
          const y = i * size/10;
          ctx.strokeStyle = 'rgba(100, 149, 237, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let x = 0; x < size; x += 4) {
            const wave = Math.sin(x * 0.1 + i) * 3;
            ctx.lineTo(x, y + wave);
          }
          ctx.stroke();
        }
        // Brilhos
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(173, 216, 230, 0.4)';
          ctx.fillRect(x, y, 3, 3);
        }
        break;

      case 'bedrock':
        // Base muito escura
        ctx.fillStyle = '#2F2F2F';
        ctx.fillRect(0, 0, size, size);
        // Padr√£o irregular
        for (let i = 0; i < size * 12; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          const shade = Math.random() * 30 - 15;
          ctx.fillStyle = `rgb(${47 + shade}, ${47 + shade}, ${47 + shade})`;
          ctx.fillRect(x, y, 4, 4);
        }
        // Manchas pretas
        for (let i = 0; i < 20; i++) {
          const x = Math.random() * size;
          const y = Math.random() * size;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
          ctx.fillRect(x, y, 6, 6);
        }
        break;

      default:
        createDefaultTexture(ctx, size, blockTypes[type]?.color || 0x808080);
        break; // ‚úÖ CORRIGIDO: Apenas break aqui
    }

    // ‚úÖ Criar e retornar a textura DEPOIS do switch
    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  function createEnhancedTexture(type, size = 64) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createEnhancedGrassTexture(ctx, size);
        break;

      case 'dirt':
        createEnhancedDirtTexture(ctx, size);
        break;

      case 'stone':
        createEnhancedStoneTexture(ctx, size);
        break;

      case 'wood':
        createEnhancedWoodTexture(ctx, size);
        break;

      case 'leaves':
        createEnhancedLeavesTexture(ctx, size);
        break;

      case 'sand':
        createEnhancedSandTexture(ctx, size);
        break;

      case 'water':
        createEnhancedWaterTexture(ctx, size);
        break;

      case 'glass':
        createEnhancedGlassTexture(ctx, size);
        break;

      case 'cobblestone':
        createEnhancedCobblestoneTexture(ctx, size);
        break;

      case 'planks':
        createEnhancedPlanksTexture(ctx, size);
        break;

      case 'brick':
        createEnhancedBrickTexture(ctx, size);
        break;

      case 'bedrock':
        createEnhancedBedrockTexture(ctx, size);
        break;

      default:
        // Usar a fun√ß√£o original para outros tipos
        return createEnhancedTexture(type, size);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    textureCache[type] = texture;
    return texture;
  }

  function createEnhancedGrassTexture(ctx, size) {
    // Base verde com gradiente
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00');
    gradient.addColorStop(0.3, '#6BCD00');
    gradient.addColorStop(0.6, '#5AB000');
    gradient.addColorStop(1, '#4A9000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de cor
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.2 + Math.random() * 0.3;
      ctx.fillStyle = `rgba(${100 + shade}, ${200 + shade}, ${0}, ${opacity})`;
      const s = 1 + Math.random() * 2;
      ctx.fillRect(x, y, s, s);
    }

    // Segunda camada - textura de grama
    for (let i = 0; i < size * 4; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${80 + shade}, ${180 + shade}, ${0}, 0.4)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Manchas escuras (terra aparecendo)
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(70, 50, 20, 0.4)');
      grd.addColorStop(1, 'rgba(70, 50, 20, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos de orvalho
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(200, 255, 150, 0.3)';
      ctx.fillRect(x, y, 2, 2);
    }

    // Detalhes de grama individual
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(90, 180, 0, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 2 - 1, y - 3 - Math.random() * 2);
      ctx.stroke();
    }
  }

  function createEnhancedDirtTexture(ctx, size) {
    // Base marrom com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#8B4513');
    gradient.addColorStop(0.5, '#7A3C0F');
    gradient.addColorStop(1, '#6B350D');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de terra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${139 + shade}, ${69 + shade}, ${19 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Pedrinhas e cascalho
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40;
      ctx.fillStyle = `rgba(${100 + shade}, ${100 + shade}, ${100 + shade}, 0.4)`;
      const s = 1 + Math.random() * 3;
      ctx.fillRect(x, y, s, s);
    }

    // Ra√≠zes e material org√¢nico
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(60, 40, 20, 0.5)';
      ctx.lineWidth = 1 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 8 - 4, y + Math.random() * 8 - 4);
      ctx.stroke();
    }

    // Manchas √∫midas
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(50, 30, 10, 0.3)');
      grd.addColorStop(1, 'rgba(50, 30, 10, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  function createEnhancedStoneTexture(ctx, size) {
    // Base cinza com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#888888');
    gradient.addColorStop(0.5, '#787878');
    gradient.addColorStop(1, '#686868');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de pedra
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 100 - 50;
      const opacity = 0.2 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${128 + shade}, ${128 + shade}, ${128 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Veios minerais
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(${150 + Math.random() * 50}, ${150 + Math.random() * 50}, ${150 + Math.random() * 50}, 0.4)`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 3 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Rachaduras
    for (let i = 0; i < 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.4)';
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 10 - 5, y + Math.random() * 10 - 5);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(200, 200, 200, ${0.2 + Math.random() * 0.3})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento com mais detalhe
    const centerX = size / 2;
    const centerY = size / 2;
    const maxRadius = size * 0.8;

    for (let r = 3; r < maxRadius; r += 2 + Math.random() * 3) {
      const thickness = 1 + Math.random() * 2;
      const shade = Math.random() * 50 - 25;
      const opacity = 0.2 + Math.random() * 0.4;

      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;

      ctx.beginPath();
      // Anel irregular
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.1) {
        const variation = Math.sin(angle * 8) * 2 + Math.random() * 2;
        const radius = r + variation;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();
    }

    // Veios verticais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      ctx.strokeStyle = `rgba(70, 45, 15, ${0.1 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5 + Math.random();
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + Math.random() * 4 - 2, size);
      ctx.stroke();
    }

    // N√≥s da madeira
    for (let i = 0; i < 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;

      for (let r = 0; r < radius; r += 1) {
        const shade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${50 + shade}, ${30 + shade}, ${10 + shade}, 0.3)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  function createEnhancedLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o de folhas
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      const opacity = 0.3 + Math.random() * 0.5;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 4;
      ctx.fillRect(x, y, s, s);
    }

    // Folhas individuais detalhadas
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const size_leaf = 2 + Math.random() * 3;
      const shade = Math.random() * 60 - 30;

      ctx.fillStyle = `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${0.4 + Math.random() * 0.3})`;
      ctx.beginPath();
      // Forma de folha
      ctx.ellipse(x, y, size_leaf, size_leaf * 1.5, Math.random() * Math.PI * 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Veias das folhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = `rgba(20, 100, 20, ${0.2 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.random() * 4 - 2, y + 3 + Math.random() * 2);
      ctx.stroke();
    }

    // √Åreas de luz (onde o sol passa)
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(150, 255, 100, 0.3)');
      grd.addColorStop(1, 'rgba(150, 255, 100, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Buracos/transpar√™ncia
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createEnhancedSandTexture(ctx, size) {
    // Base areia com gradiente
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, '#F4A460');
    gradient.addColorStop(0.5, '#E39450');
    gradient.addColorStop(1, '#D28440');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - gr√£os de areia
    for (let i = 0; i < size * 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${244 + shade}, ${164 + shade}, ${96 + shade}, ${opacity})`;
      ctx.fillRect(x, y, 1, 1);
    }

    // Segunda camada - gr√£os maiores
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgba(${240 + shade}, ${160 + shade}, ${90 + shade}, 0.5)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Manchas mais escuras
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(200, 140, 80, 0.3)');
      grd.addColorStop(1, 'rgba(200, 140, 80, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 220, 180, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createEnhancedWaterTexture(ctx, size) {
    // Base azul com gradiente
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#1E90FF');
    gradient.addColorStop(0.5, '#1873CC');
    gradient.addColorStop(1, '#1565C0');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Ondas (m√∫ltiplas camadas)
    for (let layer = 0; layer < 3; layer++) {
      const amplitude = 4 - layer;
      const frequency = 0.15 + layer * 0.05;
      const yOffset = layer * size / 3;

      for (let y = 0; y < size / 3; y += 2) {
        ctx.strokeStyle = `rgba(${100 + layer * 20}, ${149 + layer * 20}, ${237 + layer * 20}, ${0.3 - layer * 0.1})`;
        ctx.lineWidth = 1 + layer * 0.5;
        ctx.beginPath();

        for (let x = 0; x < size; x += 2) {
          const wave = Math.sin(x * frequency + y * 0.1) * amplitude;
          const wavY = yOffset + y + wave;

          if (x === 0) {
            ctx.moveTo(x, wavY);
          } else {
            ctx.lineTo(x, wavY);
          }
        }
        ctx.stroke();
      }
    }

    // Reflexos de luz (c√°usticos)
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 5;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(173, 216, 230, 0.5)');
      grd.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
      grd.addColorStop(1, 'rgba(173, 216, 230, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Espuma/bolhas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createEnhancedGlassTexture(ctx, size) {
    // Base transparente azulada
    const gradient = ctx.createLinearGradient(0, 0, size, size);
    gradient.addColorStop(0, 'rgba(173, 216, 230, 0.3)');
    gradient.addColorStop(0.5, 'rgba(173, 216, 230, 0.2)');
    gradient.addColorStop(1, 'rgba(173, 216, 230, 0.3)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Reflexos diagonais
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const angle = Math.random() * Math.PI / 4 - Math.PI / 8;

      ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.3})`;
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
      ctx.stroke();
    }

    // Brilhos pontuais
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
      grd.addColorStop(1, 'rgba(255, 255, 255, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Imperfei√ß√µes (bolhas)
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 2;
      ctx.fillStyle = 'rgba(230, 240, 250, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createEnhancedCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais com mais detalhe
    const stones = 20;
    const stoneSize = size / 5;

    for (let i = 0; i < stones; i++) {
      const col = i % 5;
      const row = Math.floor(i / 5);
      const x = col * stoneSize + Math.random() * 6 - 3;
      const y = row * stoneSize + Math.random() * 6 - 3;
      const w = stoneSize - Math.random() * 8;
      const h = stoneSize - Math.random() * 8;

      // Base da pedra com gradiente
      const shade = Math.random() * 50 - 25;
      const grd = ctx.createLinearGradient(x, y, x + w, y + h);
      grd.addColorStop(0, `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`);
      grd.addColorStop(1, `rgb(${87 + shade}, ${87 + shade}, ${87 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(x, y, w, h);

      // Textura interna da pedra
      for (let j = 0; j < 10; j++) {
        const px = x + Math.random() * w;
        const py = y + Math.random() * h;
        const pshade = Math.random() * 40 - 20;
        ctx.fillStyle = `rgba(${107 + pshade}, ${107 + pshade}, ${107 + pshade}, 0.5)`;
        ctx.fillRect(px, py, 2, 2);
      }

      // Contorno da pedra
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.6)';
      ctx.lineWidth = 1 + Math.random();
      ctx.strokeRect(x, y, w, h);

      // Destaque (luz)
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + w * 0.3, y);
      ctx.moveTo(x, y);
      ctx.lineTo(x, y + h * 0.3);
      ctx.stroke();
    }

    // Argamassa entre as pedras
    ctx.fillStyle = 'rgba(80, 80, 80, 0.5)';
    for (let i = 1; i < 5; i++) {
      ctx.fillRect(i * stoneSize - 2, 0, 4, size);
      ctx.fillRect(0, i * stoneSize - 2, size, 4);
    }
  }

  function createEnhancedPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais com detalhe
    const plankHeight = size / 5;

    for (let i = 0; i < 5; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 40 - 20;

      // Gradiente na t√°bua
      const grd = ctx.createLinearGradient(0, y, 0, y + plankHeight);
      grd.addColorStop(0, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      grd.addColorStop(0.5, `rgb(${183 + shade}, ${144 + shade}, ${97 + shade})`);
      grd.addColorStop(1, `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`);
      ctx.fillStyle = grd;
      ctx.fillRect(0, y, size, plankHeight - 3);

      // Veios da madeira
      for (let j = 0; j < 30; j++) {
        const x = Math.random() * size;
        const vshade = Math.random() * 30 - 15;
        ctx.strokeStyle = `rgba(${140 + vshade}, ${100 + vshade}, ${60 + vshade}, ${0.15 + Math.random() * 0.2})`;
        ctx.lineWidth = 0.5 + Math.random() * 0.5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.random() * 4 - 2, y + plankHeight - 3);
        ctx.stroke();
      }

      // N√≥s da madeira
      if (Math.random() > 0.6) {
        const kx = Math.random() * size;
        const ky = y + Math.random() * (plankHeight - 3);
        const kr = 2 + Math.random() * 4;

        for (let r = 0; r < kr; r++) {
          ctx.strokeStyle = `rgba(100, 70, 40, ${0.3 - r * 0.05})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(kx, ky, r, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.6)';
      ctx.fillRect(0, y + plankHeight - 3, size, 3);

      // Detalhe de sombra na linha
      ctx.fillStyle = 'rgba(60, 40, 20, 0.4)';
      ctx.fillRect(0, y + plankHeight - 3, size, 1);
    }

    // Pregos decorativos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, 1, 0, Math.PI * 2);
      ctx.fill();

      // Brilho do prego
      ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
      ctx.fillRect(x - 0.5, y - 1, 1, 0.5);
    }
  }

  function createEnhancedBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos detalhado
    const brickW = size / 5;
    const brickH = size / 10;

    for (let row = 0; row < 10; row++) {
      const offset = (row % 2) * (brickW / 2);

      for (let col = 0; col < 6; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          // Base do tijolo com gradiente
          const shade = Math.random() * 50 - 25;
          const grd = ctx.createLinearGradient(x, y, x + brickW, y + brickH);
          grd.addColorStop(0, `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`);
          grd.addColorStop(1, `rgb(${158 + shade}, ${24 + shade}, ${24 + shade})`);
          ctx.fillStyle = grd;
          ctx.fillRect(x + 1, y + 1, brickW - 3, brickH - 3);

          // Textura do tijolo
          for (let i = 0; i < 8; i++) {
            const bx = x + 1 + Math.random() * (brickW - 3);
            const by = y + 1 + Math.random() * (brickH - 3);
            const bshade = Math.random() * 40 - 20;
            ctx.fillStyle = `rgba(${178 + bshade}, ${34 + bshade}, ${34 + bshade}, 0.4)`;
            ctx.fillRect(bx, by, 2, 2);
          }

          // Destaque (luz)
          ctx.strokeStyle = 'rgba(220, 80, 80, 0.3)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + brickW - 3, y + 1);
          ctx.moveTo(x + 1, y + 1);
          ctx.lineTo(x + 1, y + brickH - 3);
          ctx.stroke();

          // Sombra
          ctx.strokeStyle = 'rgba(100, 20, 20, 0.4)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + brickW - 2, y + 1);
          ctx.lineTo(x + brickW - 2, y + brickH - 2);
          ctx.lineTo(x + 1, y + brickH - 2);
          ctx.stroke();
        }
      }
    }

    // Argamassa
    ctx.fillStyle = '#CCCCCC';
    for (let row = 0; row < 10; row++) {
      ctx.fillRect(0, row * brickH - 1, size, 2);
    }

    for (let col = 0; col < 6; col++) {
      for (let row = 0; row < 10; row++) {
        const offset = (row % 2) * (brickW / 2);
        const x = col * brickW + offset;
        ctx.fillRect(x - 1, 0, 2, size);
      }
    }
  }

  function createEnhancedBedrockTexture(ctx, size) {
    // Base muito escura
    ctx.fillStyle = '#1C1C1C';
    ctx.fillRect(0, 0, size, size);

    // Primeira camada - varia√ß√£o escura
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      const opacity = 0.3 + Math.random() * 0.4;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${28 + shade}, ${opacity})`;
      const s = 2 + Math.random() * 5;
      ctx.fillRect(x, y, s, s);
    }

    // Manchas muito escuras (quase pretas)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 6;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
      grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Cristais escuros
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.5)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Rachaduras profundas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let j = 0; j < 2 + Math.random() * 3; j++) {
        ctx.lineTo(x + Math.random() * 15 - 7.5, y + Math.random() * 15 - 7.5);
      }
      ctx.stroke();
    }

    // Brilhos m√≠sticos (roxos escuros)
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 4;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(100, 50, 150, 0.3)');
      grd.addColorStop(1, 'rgba(100, 50, 150, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }
  }

  function createGrassTexture(ctx, size) {
    // Base verde vibrante
    const gradient = ctx.createLinearGradient(0, 0, 0, size);
    gradient.addColorStop(0, '#7CFC00');
    gradient.addColorStop(0.5, '#6BCD00');
    gradient.addColorStop(1, '#5AB000');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    // Camadas de grama
    for (let layer = 0; layer < 3; layer++) {
      for (let i = 0; i < size * 10; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 50 - 25;
        const opacity = 0.3 + Math.random() * 0.4;
        ctx.fillStyle = `rgba(${100 + shade}, ${200 + shade}, ${0}, ${opacity})`;
        ctx.fillRect(x, y, 2, 2);
      }
    }

    // Manchas escuras (sombras)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 3;
      const grd = ctx.createRadialGradient(x, y, 0, x, y, radius);
      grd.addColorStop(0, 'rgba(0, 80, 0, 0.3)');
      grd.addColorStop(1, 'rgba(0, 80, 0, 0)');
      ctx.fillStyle = grd;
      ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
    }

    // Brilhos
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(150, 255, 100, 0.4)';
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createDirtTexture(ctx, size) {
    // Base marrom
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, size);

    // Textura de terra
    for (let i = 0; i < size * 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgb(${139 + shade}, ${69 + shade}, ${19 + shade})`;
      ctx.fillRect(x, y, Math.random() * 3, Math.random() * 3);
    }

    // Pedrinhas
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createStoneTexture(ctx, size) {
    // Base cinza
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de pedra
    for (let i = 0; i < size * 12; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 80 - 40;
      ctx.fillStyle = `rgb(${128 + shade}, ${128 + shade}, ${128 + shade})`;
      ctx.fillRect(x, y, Math.random() * 4, Math.random() * 4);
    }

    // Rachaduras
    ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }
  }

  function createWoodTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // An√©is de crescimento
    const centerX = size / 2;
    const centerY = size / 2;

    for (let r = 5; r < size; r += 4) {
      ctx.strokeStyle = `rgba(${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${20 + Math.random() * 20}, ${0.3 + Math.random() * 0.3})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Veios de madeira
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(80, 50, 20, 0.2)';
      ctx.fillRect(x, y, 1, size);
    }
  }

  function createLeavesTexture(ctx, size) {
    // Base verde escuro
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de folhas
    for (let i = 0; i < size * 6; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60 - 30;
      ctx.fillStyle = `rgba(${34 + shade}, ${139 + shade}, ${34 + shade}, 0.8)`;
      ctx.fillRect(x, y, 3, 3);
    }

    // Folhas individuais
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = `rgba(50, 200, 50, ${0.3 + Math.random() * 0.3})`;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function createSandTexture(ctx, size) {
    // Base areia
    ctx.fillStyle = '#F4A460';
    ctx.fillRect(0, 0, size, size);

    // Gr√£os de areia
    for (let i = 0; i < size * 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${244 + shade}, ${164 + shade}, ${96 + shade})`;
      ctx.fillRect(x, y, 1, 1);
    }
  }

  function createCobblestoneTexture(ctx, size) {
    // Base cinza escuro
    ctx.fillStyle = '#6B6B6B';
    ctx.fillRect(0, 0, size, size);

    // Pedras individuais
    const stones = 16;
    const stoneSize = size / 4;

    for (let i = 0; i < stones; i++) {
      const x = (i % 4) * stoneSize + Math.random() * 8;
      const y = Math.floor(i / 4) * stoneSize + Math.random() * 8;
      const w = stoneSize - Math.random() * 4;
      const h = stoneSize - Math.random() * 4;

      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${107 + shade}, ${107 + shade}, ${107 + shade})`;
      ctx.fillRect(x, y, w, h);

      // Contorno
      ctx.strokeStyle = 'rgba(40, 40, 40, 0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
    }
  }

  function createPlanksTexture(ctx, size) {
    // Base madeira clara
    ctx.fillStyle = '#C19A6B';
    ctx.fillRect(0, 0, size, size);

    // T√°buas horizontais
    const plankHeight = size / 4;
    for (let i = 0; i < 4; i++) {
      const y = i * plankHeight;
      const shade = Math.random() * 30 - 15;
      ctx.fillStyle = `rgb(${193 + shade}, ${154 + shade}, ${107 + shade})`;
      ctx.fillRect(0, y, size, plankHeight - 2);

      // Veios
      for (let j = 0; j < 20; j++) {
        const x = Math.random() * size;
        ctx.fillStyle = 'rgba(140, 100, 60, 0.2)';
        ctx.fillRect(x, y, 1, plankHeight);
      }

      // Linha entre t√°buas
      ctx.fillStyle = 'rgba(80, 60, 40, 0.5)';
      ctx.fillRect(0, y + plankHeight - 2, size, 2);
    }
  }

  function createBrickTexture(ctx, size) {
    // Base tijolo
    ctx.fillStyle = '#B22222';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o de tijolos
    const brickW = size / 4;
    const brickH = size / 8;

    for (let row = 0; row < 8; row++) {
      const offset = (row % 2) * (brickW / 2);
      for (let col = 0; col < 5; col++) {
        const x = col * brickW + offset;
        const y = row * brickH;

        if (x < size && y < size) {
          const shade = Math.random() * 40 - 20;
          ctx.fillStyle = `rgb(${178 + shade}, ${34 + shade}, ${34 + shade})`;
          ctx.fillRect(x, y, brickW - 2, brickH - 2);

          // Argamassa
          ctx.fillStyle = '#CCCCCC';
          ctx.fillRect(x, y + brickH - 2, brickW, 2);
          ctx.fillRect(x + brickW - 2, y, 2, brickH);
        }
      }
    }
  }

  function createObsidianTexture(ctx, size) {
    // Base preta
    ctx.fillStyle = '#1C1C2E';
    ctx.fillRect(0, 0, size, size);

    // Padr√£o v√≠treo
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 60;
      ctx.fillStyle = `rgba(${28 + shade}, ${28 + shade}, ${46 + shade}, 0.6)`;
      ctx.fillRect(x, y, 2, 2);
    }

    // Brilhos
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
      ctx.fillRect(x, y, 3, 3);
    }
  }

  function createGlowstoneTexture(ctx, size) {
    // Base luminosa
    ctx.fillStyle = '#FFFF99';
    ctx.fillRect(0, 0, size, size);

    // Cristais brilhantes
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 50;
      ctx.fillStyle = `rgb(${255}, ${255 - shade}, ${153 + shade})`;
      ctx.fillRect(x, y, 4, 4);
    }

    // Pontos de luz
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, 6);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(x - 6, y - 6, 12, 12);
    }
  }

  function createQuartzTexture(ctx, size) {
    // Base branca
    ctx.fillStyle = '#F5F5F5';
    ctx.fillRect(0, 0, size, size);

    // Veios de quartzo
    ctx.strokeStyle = 'rgba(230, 230, 230, 0.5)';
    ctx.lineWidth = 2;
    for (let i = 0; i < 15; i++) {
      ctx.beginPath();
      ctx.moveTo(Math.random() * size, Math.random() * size);
      ctx.lineTo(Math.random() * size, Math.random() * size);
      ctx.stroke();
    }

    // Cristais pequenos
    for (let i = 0; i < size * 5; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function createBookshelfTexture(ctx, size) {
    // Base madeira
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, 0, size, size);

    // Livros
    const bookWidth = size / 8;
    const bookHeight = size / 2;
    const colors = ['#8B0000', '#00008B', '#006400', '#8B4513', '#4B0082', '#FF8C00'];

    for (let i = 0; i < 8; i++) {
      const x = i * bookWidth;
      const y = size / 4;
      const color = colors[Math.floor(Math.random() * colors.length)];

      ctx.fillStyle = color;
      ctx.fillRect(x, y, bookWidth - 2, bookHeight);

      // Lombada do livro
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(x + 2, y + 5, bookWidth - 6, 2);
    }

    // Prateleiras
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(0, 0, size, 4);
    ctx.fillRect(0, size - 4, size, 4);
  }

  function createDefaultTexture(ctx, size, color) {
    const r = (color >> 16) & 255;
    const g = (color >> 8) & 255;
    const b = color & 255;

    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do b√°sico
    for (let i = 0; i < size * 8; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgb(${r + shade}, ${g + shade}, ${b + shade})`;
      ctx.fillRect(x, y, 2, 2);
    }
  }

  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyT' && multiplayer.connected && !document.getElementById('multiplayer-chat').classList.contains('open')) {
      e.preventDefault();
      openChat();
    }

    if (e.code === 'Escape' && document.getElementById('multiplayer-chat').classList.contains('open')) {
      closeChat();
    }
  });

  document.getElementById('chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      sendChatMessage(e.target.value);
    }
  });

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 60, 120);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 25, 0);

    renderer = new THREE.WebGLRenderer({
      antialias: true,
      powerPreference: "high-performance",
      alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

    // ‚úÖ MOVER ESTA LINHA PARA C√Å (depois do renderer)
    setupShadowSystem();

    document.body.appendChild(renderer.domElement);

    raycaster = new THREE.Raycaster();
    raycaster.far = REACH;

    // Ilumina√ß√£o
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(100, 100, 50);
    setupSunShadows(sun);
    scene.add(sun);

    const ambient = new THREE.AmbientLight(0x404040, 0.9);
    scene.add(ambient);

    addAmbientOcclusion();
    addVolumetricShadows();

    createSky();
    createClouds();
    waterSystem = new WaterSystem();
    particleSystem = new ParticleSystem();

    // ‚úÖ CRIAR MATERIAIS AQUI (depois de tudo estar pronto)
    createMaterialsWithEmissive();

    initializeInventory();
    createHealthUI();
    createInventoryUI();
    createFullInventoryUI();
    setupEventListeners();

    enableSoftShadows();
    loadSettings();
  }

  function buildWatchTower(x, y, z) {
    // Base da torre (5x5)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Paredes da torre (3x3 interna)
    for (let dy = 0; dy < 12; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
          if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
            // Abertura para entrada
            if (dy === 0 && dx === 2 && dz === 0) {
              continue;
            }
            // Aberturas para janelas/amiras
            if (dy > 5 && dy < 10 && (dx === 2 || dz === 2)) {
              if (Math.random() > 0.7) {
                continue;
              }
            }
            setBlock(x + dx, y + dy, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Escada interna em espiral
    const stairBlocks = [
      { x: 1, z: 1, yOffset: 0 },
      { x: 1, z: 0, yOffset: 1 },
      { x: 1, z: -1, yOffset: 2 },
      { x: 0, z: -1, yOffset: 3 },
      { x: -1, z: -1, yOffset: 4 },
      { x: -1, z: 0, yOffset: 5 },
      { x: -1, z: 1, yOffset: 6 },
      { x: 0, z: 1, yOffset: 7 }
    ];

    for (let level = 0; level < 10; level++) {
      const stair = stairBlocks[level % stairBlocks.length];
      setBlock(x + stair.x, y + level, z + stair.z, 'planks');

      // Remover bloco acima para passagem
      removeBlockData(x + stair.x, y + level + 1, z + stair.z);
    }

    // Topo da torre com ameias
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        if (Math.abs(dx) === 2 || Math.abs(dz) === 2) {
          setBlock(x + dx, y + 12, z + dz, 'cobblestone');
          // Ameias alternadas
          if ((dx + dz) % 2 === 0) {
            setBlock(x + dx, y + 13, z + dz, 'cobblestone');
          }
        }
      }
    }

    // Laje superior
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 12, z + dz, 'planks');
      }
    }

    // Tocha no topo
    setBlock(x, y + 14, z, 'torch');

    // Poste com lanterna na entrada
    setBlock(x + 3, y, z, 'planks');
    setBlock(x + 3, y + 1, z, 'planks');
    setBlock(x + 3, y + 2, z, 'lantern');

    // Bandeira decorativa (usando madeira e l√£)
    for (let dy = 0; dy < 4; dy++) {
      setBlock(x - 2, y + 8 + dy, z - 2, 'wood');
    }

    // Bandeira (bloco de l√£ vermelha)
    setBlock(x - 2, y + 12, z - 2, 'concrete_red');
    setBlock(x - 2, y + 12, z - 3, 'concrete_red');
    setBlock(x - 3, y + 12, z - 2, 'concrete_red');

    // Pequeno arsenal dentro da torre
    setBlock(x, y + 1, z, 'chest');
    setBlock(x, y + 2, z, 'planks'); // Prateleira
  }

  function buildDetailedFarm(x, y, z) {
    // Cerca externa expandida (16x16)
    for (let dx = -8; dx <= 8; dx++) {
      setBlock(x + dx, y, z - 8, 'planks');
      setBlock(x + dx, y + 1, z - 8, 'planks');
      setBlock(x + dx, y, z + 8, 'planks');
      setBlock(x + dx, y + 1, z + 8, 'planks');
    }
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 8, y, z + dz, 'planks');
      setBlock(x - 8, y + 1, z + dz, 'planks');
      setBlock(x + 8, y, z + dz, 'planks');
      setBlock(x + 8, y + 1, z + dz, 'planks');
    }

    // Port√£o de entrada
    removeBlockData(x, y, z + 8);
    removeBlockData(x, y + 1, z + 8);
    removeBlockData(x + 1, y, z + 8);
    removeBlockData(x + 1, y + 1, z + 8);

    // Campos cultivados com canais de irriga√ß√£o
    for (let section = 0; section < 2; section++) {
      const baseZ = section === 0 ? -6 : 2;

      for (let dx = -6; dx <= -1; dx++) {
        for (let dz = 0; dz < 4; dz++) {
          if (dx === -3 || dx === -4) {
            // Canal de √°gua
            setBlock(x + dx, y, z + baseZ + dz, 'glass'); // √Ågua
          } else {
            // Terra cultivada
            setBlock(x + dx, y, z + baseZ + dz, 'dirt');

            // Plantas em diferentes est√°gios
            if (Math.random() > 0.3) {
              const plants = ['leaves', 'mushroom_brown', 'pumpkin'];
              setBlock(x + dx, y + 1, z + baseZ + dz,
                      plants[Math.floor(Math.random() * plants.length)]);
            }
          }
        }
      }
    }

    // Campo de mel√µes
    for (let dx = 1; dx <= 6; dx++) {
      for (let dz = -6; dz <= -2; dz++) {
        setBlock(x + dx, y, z + dz, 'dirt');
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y + 1, z + dz, 'melon');
        }
      }
    }

    // Pomar (√°rvores frut√≠feras)
    const treesPos = [
      { dx: 4, dz: 2 }, { dx: 6, dz: 4 }, { dx: 2, dz: 5 }
    ];

    treesPos.forEach(pos => {
      // Tronco
      for (let dy = 1; dy <= 3; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'wood');
      }
      // Copa
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          setBlock(x + pos.dx + dx, y + 4, z + pos.dz + dz, 'leaves');
          if (Math.random() > 0.5) {
            setBlock(x + pos.dx + dx, y + 3, z + pos.dz + dz, 'leaves');
          }
        }
      }
      // "Frutas" (manchas vermelhas nas folhas)
      if (Math.random() > 0.5) {
        setBlock(x + pos.dx + 1, y + 4, z + pos.dz, 'mushroom_red');
      }
    });

    // Celeiro grande (8x6)
    const barnX = x - 10;
    const barnZ = z;

    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(barnX + dx, y - 1, barnZ + dz, 'planks');
      }
    }

    // Paredes do celeiro
    for (let dy = 0; dy < 5; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 3) {
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 3) {
              continue; // Porta grande
            }
            setBlock(barnX + dx, y + dy, barnZ + dz, 'planks');
          }
        }
      }
    }

    // Telhado do celeiro
    for (let dy = 0; dy < 3; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -3; dz <= 3; dz++) {
          setBlock(barnX + dx, y + 5 + dy, barnZ + dz, 'brick');
        }
      }
    }

    // Janela do celeiro (s√≥t√£o)
    setBlock(barnX, y + 6, barnZ + 3, 'glass');

    // Interior do celeiro - Baias
    setBlock(barnX - 3, y + 1, barnZ - 2, 'planks');
    setBlock(barnX - 3, y + 1, barnZ, 'planks');
    setBlock(barnX - 3, y + 1, barnZ + 2, 'planks');

    // Armazenamento (ba√∫s e barris)
    setBlock(barnX + 3, y + 1, barnZ - 2, 'chest');
    setBlock(barnX + 3, y + 1, barnZ - 1, 'chest');
    setBlock(barnX + 3, y + 1, barnZ, 'chest');

    // Ferramentas na parede
    setBlock(barnX + 3, y + 2, barnZ + 2, 'planks');

    // Moinho de vento decorativo
    const millX = x + 12;
    const millZ = z;

    // Base do moinho (torre)
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
            setBlock(millX + dx, y + dy, millZ + dz, 'cobblestone');
          }
        }
      }
    }

    // Topo do moinho
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(millX + dx, y + 8, millZ + dz, 'brick');
      }
    }

    // P√°s do moinho (simplificadas)
    // Horizontal
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(millX + dx, y + 5, millZ, 'planks');
    }
    // Vertical
    for (let dz = -3; dz <= 3; dz++) {
      setBlock(millX, y + 5 + dz - 3, millZ, 'planks');
    }

    // Janelas do moinho
    setBlock(millX + 1, y + 3, millZ + 1, 'glass');
    setBlock(millX - 1, y + 6, millZ - 1, 'glass');

    // Ilumina√ß√£o
    setBlock(x, y, z, 'planks');
    setBlock(x, y + 1, z, 'planks');
    setBlock(x, y + 2, z, 'lantern');

    setBlock(barnX, y, barnZ + 4, 'planks');
    setBlock(barnX, y + 1, barnZ + 4, 'planks');
    setBlock(barnX, y + 2, barnZ + 4, 'lantern');
  }

  function buildGrandLibrary(x, y, z) {
    // Base expandida (11x11)
    for (let dx = -5; dx <= 5; dx++) {
      for (let dz = -5; dz <= 5; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'planks');
      }
    }

    // Paredes principais
    for (let dy = 0; dy < 7; dy++) {
      for (let dx = -5; dx <= 5; dx++) {
        for (let dz = -5; dz <= 5; dz++) {
          if (Math.abs(dx) === 5 || Math.abs(dz) === 5) {
            // Porta dupla
            if (dy <= 2 && dx >= -1 && dx <= 1 && dz === 5) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Segundo andar
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -4; dz <= 4; dz++) {
        setBlock(x + dx, y + 7, z + dz, 'planks');
      }
    }

    // Paredes segundo andar
    for (let dy = 8; dy < 14; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -4; dz <= 4; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 4) {
            setBlock(x + dx, y + dy, z + dz, 'planks');
          }
        }
      }
    }

    // Janelas primeiro andar
    const firstFloorWindows = [
      { dx: -5, dz: -3 }, { dx: -5, dz: 0 }, { dx: -5, dz: 3 },
      { dx: 5, dz: -3 }, { dx: 5, dz: 0 }, { dx: 5, dz: 3 },
      { dx: -3, dz: -5 }, { dx: 0, dz: -5 }, { dx: 3, dz: -5 }
    ];

    firstFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');
    });

    // Janelas segundo andar
    const secondFloorWindows = [
      { dx: -4, dz: -2 }, { dx: -4, dz: 2 },
      { dx: 4, dz: -2 }, { dx: 4, dz: 2 },
      { dx: -2, dz: -4 }, { dx: 2, dz: -4 }
    ];

    secondFloorWindows.forEach(pos => {
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 11, z + pos.dz, 'glass');
    });

    // Estantes ao longo das paredes - Primeiro andar
    const shelfPositions1F = [];
    for (let dz = -4; dz <= 4; dz += 2) {
      shelfPositions1F.push({ dx: -4, dz: dz });
      shelfPositions1F.push({ dx: 4, dz: dz });
    }
    for (let dx = -4; dx <= 4; dx += 2) {
      if (Math.abs(dx) !== 4) {
        shelfPositions1F.push({ dx: dx, dz: -4 });
      }
    }

    shelfPositions1F.forEach(pos => {
      for (let dy = 1; dy <= 5; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Estantes segundo andar
    const shelfPositions2F = [];
    for (let dz = -3; dz <= 3; dz += 2) {
      shelfPositions2F.push({ dx: -3, dz: dz });
      shelfPositions2F.push({ dx: 3, dz: dz });
    }
    for (let dx = -3; dx <= 3; dx += 2) {
      shelfPositions2F.push({ dx: dx, dz: -3 });
      shelfPositions2F.push({ dx: dx, dz: 3 });
    }

    shelfPositions2F.forEach(pos => {
      for (let dy = 8; dy <= 12; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'bookshelf');
      }
    });

    // Mesa de leitura central - Primeiro andar
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 1, z + dz, 'planks');
      }
    }

    // Cadeiras ao redor da mesa
    setBlock(x - 2, y + 1, z, 'planks');
    setBlock(x + 2, y + 1, z, 'planks');
    setBlock(x, y + 1, z - 2, 'planks');
    setBlock(x, y + 1, z + 2, 'planks');

    // Mesa de trabalho e ba√∫
    setBlock(x + 3, y + 1, z + 3, 'crafting_table');
    setBlock(x + 3, y + 1, z + 4, 'chest');

    // Escada para o segundo andar
    for (let dy = 0; dy < 7; dy++) {
      setBlock(x + 4, y + dy, z - 4, 'planks');
      setBlock(x + 4, y + dy, z - 3, 'planks');
    }

    // Mesa de estudos segundo andar
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 8, z, 'planks');
    }

    // Globo decorativo
    setBlock(x - 2, y + 8, z - 2, 'planks');
    setBlock(x - 2, y + 9, z - 2, 'gold_ore');

    // Telhado em camadas
    for (let dy = 0; dy < 4; dy++) {
      const size = 5 - dy;
      for (let dx = -size; dx <= size; dx++) {
        for (let dz = -size; dz <= size; dz++) {
          setBlock(x + dx, y + 14 + dy, z + dz, 'brick');
        }
      }
    }

    // Torre de observa√ß√£o/estudo no topo
    for (let dy = 0; dy < 5; dy++) {
      setBlock(x, y + 18 + dy, z, 'planks');
      setBlock(x + 1, y + 18 + dy, z, 'planks');
      setBlock(x - 1, y + 18 + dy, z, 'planks');
      setBlock(x, y + 18 + dy, z + 1, 'planks');
      setBlock(x, y + 18 + dy, z - 1, 'planks');
    }

    // Janelas da torre
    setBlock(x + 1, y + 21, z, 'glass');
    setBlock(x - 1, y + 21, z, 'glass');
    setBlock(x, y + 21, z + 1, 'glass');
    setBlock(x, y + 21, z - 1, 'glass');

    // Topo da torre com lanterna
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + dx, y + 23, z + dz, 'brick');
      }
    }
    setBlock(x, y + 24, z, 'glowstone');

    // Ilumina√ß√£o interna - Candelabros
    const lightPos = [
      { dx: -3, dz: -3 }, { dx: 3, dz: -3 },
      { dx: -3, dz: 3 }, { dx: 3, dz: 3 }
    ];

    lightPos.forEach(pos => {
      // Primeiro andar
      setBlock(x + pos.dx, y + 1, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'lantern');

      // Segundo andar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 9, z + pos.dz, 'planks');
      setBlock(x + pos.dx, y + 10, z + pos.dz, 'lantern');
    });

    // Entrada decorativa com colunas
    setBlock(x - 2, y, z + 6, 'quartz');
    setBlock(x - 2, y + 1, z + 6, 'quartz');
    setBlock(x - 2, y + 2, z + 6, 'quartz');
    setBlock(x - 2, y + 3, z + 6, 'lantern');

    setBlock(x + 2, y, z + 6, 'quartz');
    setBlock(x + 2, y + 1, z + 6, 'quartz');
    setBlock(x + 2, y + 2, z + 6, 'quartz');
    setBlock(x + 2, y + 3, z + 6, 'lantern');

    // Placa decorativa
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 5, z + 5, 'planks');
    }

    // Jardim de leitura ao ar livre
    for (let dx = -7; dx <= -6; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.6) {
          setBlock(x + dx, y + 1, z + dz, 'mushroom_red');
        }
      }
    }

    // Bancos no jardim
    setBlock(x - 6, y + 1, z - 1, 'planks');
    setBlock(x - 6, y + 1, z, 'planks');
    setBlock(x - 6, y + 1, z + 1, 'planks');
  }

  function generateChunk(cx, cz) {
    const chunkKey = getChunkKey(cx, cz);
    if (chunks[chunkKey]) return;

    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    for (let x = sx; x < sx + CHUNK_SIZE; x++) {
      for (let z = sz; z < sz + CHUNK_SIZE; z++) {
        const height = getHeight(x, z);

        // Bedrock na base
        setBlock(x, 0, z, 'bedrock');

        // Camadas subterr√¢neas
        const stoneHeight = height - 4;
        for (let y = 1; y < stoneHeight; y++) {
          setBlock(x, y, z, 'stone');
        }

        for (let y = stoneHeight; y < height - 1; y++) {
          setBlock(x, y, z, 'dirt');
        }

        setBlock(x, height - 1, z, 'dirt');
        setBlock(x, height, z, 'grass');

        // Adicionar √°rvores
        if (Math.random() > 0.99 && height < 50) {
          generateTree(x, height + 1, z);
        }

        // Adicionar √°gua em vales
        if (height < 10 && Math.random() > 0.7) {
          for (let y = height + 1; y <= 10; y++) {
            setBlock(x, y, z, 'water');
            waterSystem.createWaterBlock(x, y, z);
          }
        }

        // Flores e vegeta√ß√£o
        if (Math.random() > 0.95 && height < 40) {
          setBlock(x, height + 1, z, 'leaves');
        }
      }
    }

    chunks[chunkKey] = true;
  }

  function generateTree(x, y, z) {
    const treeHeight = Math.floor(Math.random() * 4) + 4;

    // Tronco
    for (let i = 0; i < treeHeight; i++) {
      setBlock(x, y + i, z, 'wood');
    }

    // Copa
    const topY = y + treeHeight - 1;
    for (let dx = -2; dx <= 2; dx++) {
      for (let dz = -2; dz <= 2; dz++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 3) {
            setBlock(x + dx, topY + dy, z + dz, 'leaves');
          }
        }
      }
    }
  }

  function removeBlock(x, y, z) {
    const block = getBlock(x, y, z);
    if (!block || block.type === 'bedrock') return;

    // Criar part√≠culas do bloco quebrado
    if (particleSystem) {
      const color = blockTypes[block.type] ? blockTypes[block.type].color : 0xFFFFFF;
      particleSystem.emit(
              new THREE.Vector3(x, y, z),
              color,
              15,
              0.2
      );
    }

    // Remover √°gua se for bloco de √°gua
    if (block.type === 'water') {
      waterSystem.removeWater(x, y, z);
    }

    addToInventory(block.type, 1);
    removeBlockData(x, y, z);

    // Reconstruir chunks
    const chunk = worldToChunk(x, z);
    const chunksToUpdate = new Set();
    chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

    const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
    const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

    if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
    if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
    if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
    if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

    chunksToUpdate.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      if (chunkMeshes[key]) {
        buildChunkMesh(cx, cz);
      }
    });

    updateFaceCount();
  }

  function placeBlock(x, y, z, type) {
    if (getBlock(x, y, z)) return;

    // Verificar se o bloco est√° dentro do jogador
    const playerBox = new THREE.Box3(
            new THREE.Vector3(
                    camera.position.x - PLAYER_WIDTH/2,
                    camera.position.y - PLAYER_HEIGHT/2,
                    camera.position.z - PLAYER_WIDTH/2
            ),
            new THREE.Vector3(
                    camera.position.x + PLAYER_WIDTH/2,
                    camera.position.y + PLAYER_HEIGHT/2,
                    camera.position.z + PLAYER_WIDTH/2
            )
    );

    const blockBox = new THREE.Box3(
            new THREE.Vector3(x - 0.5, y - 0.5, z - 0.5),
            new THREE.Vector3(x + 0.5, y + 0.5, z + 0.5)
    );

    if (playerBox.intersectsBox(blockBox)) return;

    // Verificar se tem o item no invent√°rio
    const selectedItem = getSelectedItem();
    if (selectedItem === type && removeFromInventory(player.selectedSlot, 1)) {
      setBlock(x, y, z, type);

      // ‚ú® ILUMINA√á√ÉO: Adicionar luz se o bloco for emissivo
      if (blockTypes[type] && blockTypes[type].emissive) {
        addBlockLight(x, y, z, type);
      }

      // Se for √°gua, criar mesh especial
      if (type === 'water') {
        waterSystem.createWaterBlock(x, y, z);
        // Adicionar ilumina√ß√£o suave para √°gua
        addWaterLighting(x, y, z);
      }

      // ‚úÖ SINCRONIZAR MULTIPLAYER
      if (multiplayer.connected) {
        console.log('üì§ Sincronizando coloca√ß√£o de bloco:', type, 'em', x, y, z);
        sendMultiplayerMessage({
          type: 'block_place',
          x: Math.floor(x),
          y: Math.floor(y),
          z: Math.floor(z),
          blockType: type
        });
      }

      // Reconstruir chunks afetados
      const chunk = worldToChunk(x, z);
      const chunksToUpdate = new Set();
      chunksToUpdate.add(getChunkKey(chunk.x, chunk.z));

      const localX = ((x % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
      const localZ = ((z % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;

      if (localX === 0) chunksToUpdate.add(getChunkKey(chunk.x - 1, chunk.z));
      if (localX === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x + 1, chunk.z));
      if (localZ === 0) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z - 1));
      if (localZ === CHUNK_SIZE - 1) chunksToUpdate.add(getChunkKey(chunk.x, chunk.z + 1));

      chunksToUpdate.forEach(key => {
        const [cx, cz] = key.split(',').map(Number);
        if (chunkMeshes[key]) {
          buildChunkMesh(cx, cz);
        }
      });

      updateFaceCount();
    }
  }

  function buildImprovedChurch(x, y, z) {
    // Base maior e mais elaborada (9x14)
    for (let dx = -4; dx <= 4; dx++) {
      for (let dz = -7; dz <= 7; dz++) {
        setBlock(x + dx, y - 1, z + dz, 'cobblestone');
      }
    }

    // Escadaria na entrada
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y, z + 8, 'cobblestone');
      setBlock(x + dx, y + 1, z + 9, 'cobblestone');
    }

    // Paredes principais
    for (let dy = 0; dy < 8; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          if (Math.abs(dx) === 4 || Math.abs(dz) === 7) {
            // Porta principal (dupla e alta)
            if (dy <= 3 && dx >= -1 && dx <= 1 && dz === 7) {
              continue;
            }
            setBlock(x + dx, y + dy, z + dz, 'quartz');
          }
        }
      }
    }

    // Pilares decorativos nas laterais
    const pillarPositions = [
      { dx: -4, dz: -5 }, { dx: -4, dz: 0 }, { dx: -4, dz: 5 },
      { dx: 4, dz: -5 }, { dx: 4, dz: 0 }, { dx: 4, dz: 5 }
    ];

    pillarPositions.forEach(pos => {
      for (let dy = 0; dy < 8; dy++) {
        setBlock(x + pos.dx, y + dy, z + pos.dz, 'quartz');

        // Detalhe do pilar
        if (dy % 2 === 0) {
          if (pos.dx === -4) {
            setBlock(x + pos.dx - 1, y + dy, z + pos.dz, 'cobblestone');
          } else {
            setBlock(x + pos.dx + 1, y + dy, z + pos.dz, 'cobblestone');
          }
        }
      }
      // Topo do pilar
      setBlock(x + pos.dx, y + 8, z + pos.dz, 'cobblestone');
    });

    // Janelas laterais em arco (vitrais)
    const windowPositions = [
      { dx: -4, dz: -3 }, { dx: -4, dz: 3 },
      { dx: 4, dz: -3 }, { dx: 4, dz: 3 }
    ];

    windowPositions.forEach(pos => {
      // Janela em arco (3 blocos de altura)
      setBlock(x + pos.dx, y + 3, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 4, z + pos.dz, 'glass');
      setBlock(x + pos.dx, y + 5, z + pos.dz, 'glass');

      // Moldura da janela
      setBlock(x + pos.dx, y + 2, z + pos.dz, 'cobblestone');
      setBlock(x + pos.dx, y + 6, z + pos.dz, 'cobblestone');
    });

    // Janela grande frontal (ros√°cea)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 5; dy <= 7; dy++) {
        if (Math.abs(dx) <= 2 && dy >= 5) {
          setBlock(x + dx, y + dy, z + 7, 'glass');
        }
      }
    }
    // Moldura da ros√°cea
    for (let dx = -3; dx <= 3; dx++) {
      setBlock(x + dx, y + 4, z + 7, 'cobblestone');
      setBlock(x + dx, y + 8, z + 7, 'cobblestone');
    }

    // Torre do sino (central, mais alta e detalhada)
    for (let dy = 0; dy < 15; dy++) {
      // Base da torre (3x3)
      if (dy < 8) {
        for (let dx = -1; dx <= 1; dx++) {
          for (let dz = -1; dz <= 1; dz++) {
            if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
              setBlock(x + dx, y + 8 + dy, z + dz, 'quartz');
            }
          }
        }
      } else {
        // Torre estreita no topo
        setBlock(x, y + 8 + dy, z, 'quartz');
        setBlock(x + 1, y + 8 + dy, z, 'quartz');
        setBlock(x - 1, y + 8 + dy, z, 'quartz');
        setBlock(x, y + 8 + dy, z + 1, 'quartz');
        setBlock(x, y + 8 + dy, z - 1, 'quartz');
      }
    }

    // Sino (vis√≠vel)
    setBlock(x, y + 18, z, 'gold_ore'); // Sino dourado

    // Aberturas da torre do sino
    setBlock(x + 1, y + 17, z, 'glass');
    setBlock(x - 1, y + 17, z, 'glass');
    setBlock(x, y + 17, z + 1, 'glass');
    setBlock(x, y + 17, z - 1, 'glass');

    // Cruz no topo da torre
    for (let dy = 0; dy < 3; dy++) {
      setBlock(x, y + 23 + dy, z, 'gold_ore');
    }
    setBlock(x - 1, y + 24, z, 'gold_ore');
    setBlock(x + 1, y + 24, z, 'gold_ore');

    // Topo da cruz brilhante
    setBlock(x, y + 26, z, 'glowstone');

    // Telhado principal (em V invertido)
    for (let dy = 0; dy < 5; dy++) {
      const width = 4 - dy;
      for (let dx = -width; dx <= width; dx++) {
        for (let dz = -7; dz <= 7; dz++) {
          setBlock(x + dx, y + 8 + dy, z + dz, 'brick');
        }
      }
    }

    // Detalhes do telhado (beirais)
    for (let dz = -7; dz <= 7; dz++) {
      setBlock(x - 5, y + 8, z + dz, 'cobblestone');
      setBlock(x + 5, y + 8, z + dz, 'cobblestone');
    }

    // Interior - Nave central
    for (let dx = -3; dx <= 3; dx++) {
      for (let dz = -6; dz <= 6; dz++) {
        // Piso de pedra decorativo
        if ((dx + dz) % 2 === 0) {
          setBlock(x + dx, y, z + dz, 'quartz');
        } else {
          setBlock(x + dx, y, z + dz, 'cobblestone');
        }
      }
    }

    // Altar
    for (let dx = -2; dx <= 2; dx++) {
      setBlock(x + dx, y + 1, z - 6, 'quartz');
    }
    for (let dx = -1; dx <= 1; dx++) {
      setBlock(x + dx, y + 2, z - 6, 'quartz');
    }
    setBlock(x, y + 3, z - 6, 'gold_ore'); // Cruz dourada no altar

    // Bancos (fileiras)
    for (let row = -4; row <= 2; row += 2) {
      // Banco esquerdo
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x - 2, y + 1, z + row + dz, 'planks');
      }
      // Banco direito
      for (let dz = 0; dz < 3; dz++) {
        setBlock(x + 2, y + 1, z + row + dz, 'planks');
      }
    }

    // Candelabros (lanternas suspensas)
    const chandPos = [
      { dz: -4 }, { dz: 0 }, { dz: 4 }
    ];

    chandPos.forEach(pos => {
      // Corrente
      for (let dy = 1; dy <= 4; dy++) {
        setBlock(x, y + dy + 3, z + pos.dz, 'planks');
      }
      // Lanterna
      setBlock(x, y + 3, z + pos.dz, 'lantern');
      setBlock(x + 1, y + 3, z + pos.dz, 'lantern');
      setBlock(x - 1, y + 3, z + pos.dz, 'lantern');
    });

    // Tochas nas paredes
    setBlock(x - 3, y + 3, z - 5, 'torch');
    setBlock(x + 3, y + 3, z - 5, 'torch');
    setBlock(x - 3, y + 3, z, 'torch');
    setBlock(x + 3, y + 3, z, 'torch');
    setBlock(x - 3, y + 3, z + 5, 'torch');
    setBlock(x + 3, y + 3, z + 5, 'torch');

    // √ìrg√£o de tubos (decorativo na parede dos fundos)
    for (let dx = -2; dx <= 2; dx++) {
      for (let dy = 2; dy <= 6; dy++) {
        if (Math.abs(dx) === 2 || dy >= 5) {
          setBlock(x + dx, y + dy, z - 7, 'planks');
        }
      }
    }

    // Jardim lateral direito
    for (let dx = 5; dx <= 7; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // Jardim lateral esquerdo
    for (let dx = -7; dx <= -5; dx++) {
      for (let dz = -3; dz <= 3; dz++) {
        setBlock(x + dx, y, z + dz, 'grass');
        if (Math.random() > 0.7) {
          setBlock(x + dx, y + 1, z + dz, 'leaves');
        }
      }
    }

    // √Årvores decorativas ao lado
    const treePosLeft = { dx: -6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosLeft.dx, y + dy, z + treePosLeft.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosLeft.dx + dx, y + 5, z + treePosLeft.dz + dz, 'leaves');
      }
    }

    const treePosRight = { dx: 6, dz: 0 };
    for (let dy = 1; dy <= 4; dy++) {
      setBlock(x + treePosRight.dx, y + dy, z + treePosRight.dz, 'wood');
    }
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        setBlock(x + treePosRight.dx + dx, y + 5, z + treePosRight.dz + dz, 'leaves');
      }
    }

    // Cerca decorativa ao redor do jardim
    for (let dx = -8; dx <= 8; dx++) {
      if (Math.abs(dx) >= 5) {
        setBlock(x + dx, y, z - 4, 'planks');
        setBlock(x + dx, y, z + 4, 'planks');
      }
    }

    // Lanternas de ilumina√ß√£o externa
    setBlock(x - 5, y, z + 8, 'planks');
    setBlock(x - 5, y + 1, z + 8, 'planks');
    setBlock(x - 5, y + 2, z + 8, 'lantern');

    setBlock(x + 5, y, z + 8, 'planks');
    setBlock(x + 5, y + 1, z + 8, 'planks');
    setBlock(x + 5, y + 2, z + 8, 'lantern');

    // Lanternas na torre
    setBlock(x - 2, y + 15, z - 2, 'lantern');
    setBlock(x + 2, y + 15, z - 2, 'lantern');
    setBlock(x - 2, y + 15, z + 2, 'lantern');
    setBlock(x + 2, y + 15, z + 2, 'lantern');
  }

  function startGame() {
    document.getElementById('main-menu').style.display = 'none';

    const chunk = worldToChunk(0, 0);
    player.lastChunk = chunk;

    const chunksToLoad = [];
    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        chunksToLoad.push([cx, cz]);
      }
    }

    chunksToLoad.forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
    });

    chunksToLoad.forEach(([cx, cz]) => {
      buildChunkMesh(cx, cz);
    });

    // Criar personagem
    playerCharacter = new PlayerCharacter();
    playerCharacter.setPosition(0, 25, 0);
    scene.add(playerCharacter.group);

    // Spawnar inimigos
    chunksToLoad.forEach(([cx, cz]) => {
      spawnEnemies(cx, cz);
    });

    // Gerar vila
    generateVillage(30, 30);

    controls.locked = true;
    renderer.domElement.requestPointerLock();

    animate();
  }


  blockTypes.water = { color: 0x1E90FF, name: '√Ågua', hardness: 0.5 };


  function cleanupUnusedResources() {
    // Limpar geometrias n√£o utilizadas
    for (let key in chunkMeshes) {
      const chunk = chunkMeshes[key];
      if (!scene.children.includes(chunk)) {
        chunk.children.forEach(child => {
          child.geometry.dispose();
          child.material.dispose();
        });
        delete chunkMeshes[key];
      }
    }

    // Limpar part√≠culas antigas
    if (particles.length > 1000) {
      particles.splice(0, particles.length - 1000).forEach(p => {
        scene.remove(p);
        p.geometry.dispose();
        p.material.dispose();
      });
    }

    // Limpar anima√ß√µes de quebra antigas
    if (breakingAnimations.length > 50) {
      breakingAnimations.splice(0, breakingAnimations.length - 50).forEach(anim => {
        anim.particles.forEach(p => {
          scene.remove(p);
          p.geometry.dispose();
          p.material.dispose();
        });
      });
    }
  }

  setInterval(cleanupUnusedResources, 30000);


  document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1) {
      e.preventDefault();
    }
  }, { passive: false });

  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, false);
  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const settingsBtn = document.createElement('button');
      settingsBtn.className = 'menu-settings-btn';
      settingsBtn.innerHTML = '‚öôÔ∏è Configura√ß√µes';
      settingsBtn.onclick = openSettings;
      menuContainer.appendChild(settingsBtn);
    }
  });

  function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    z-index: 10000;
    animation: slideIn 0.3s ease;
  `;
    notification.textContent = message;

    document.body.appendChild(notification);

    setTimeout(() => {
      notification.style.animation = 'slideOut 0.3s ease';
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  const style = document.createElement('style');
  style.textContent = `
  @keyframes slideIn {
    from { transform: translateX(400px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }
  @keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(400px); opacity: 0; }
  }
`;
  document.head.appendChild(style);


  document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && controls.locked) {
      openSettings();
      document.exitPointerLock();
      controls.locked = false;
    }
  });

  const frustum = new THREE.Frustum();
  const cameraViewProjectionMatrix = new THREE.Matrix4();

  function updateVisibleChunks() {
    const px = camera.position.x;
    const pz = camera.position.z;
    const chunk = worldToChunk(px, pz);

    // Atualizar frustum
    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    // Calcular prioridades de chunks
    const chunkPriorities = [];

    for (let cx = chunk.x - RENDER_DISTANCE; cx <= chunk.x + RENDER_DISTANCE; cx++) {
      for (let cz = chunk.z - RENDER_DISTANCE; cz <= chunk.z + RENDER_DISTANCE; cz++) {
        const chunkKey = getChunkKey(cx, cz);

        if (!isChunkInFrustum(cx, cz)) continue;

        const dx = cx - chunk.x;
        const dz = cz - chunk.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        // Calcular dire√ß√£o da c√¢mera
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);

        const chunkDir = new THREE.Vector3(
                cx * CHUNK_SIZE - px,
                0,
                cz * CHUNK_SIZE - pz
        ).normalize();

        const alignment = cameraDir.dot(chunkDir);

        // Prioridade: dist√¢ncia + alinhamento com c√¢mera
        const priority = distance * 10 - alignment * 5;

        chunkPriorities.push({ cx, cz, priority, chunkKey, distance });
      }
    }

    // Ordenar por prioridade
    chunkPriorities.sort((a, b) => a.priority - b.priority);

    // Processar chunks de alta prioridade primeiro
    const chunksToGenerate = [];
    const chunksToMesh = [];

    chunkPriorities.forEach(({ cx, cz, chunkKey, distance }) => {
      if (!chunks[chunkKey]) {
        chunksToGenerate.push([cx, cz, distance]);
      } else if (!chunkMeshes[chunkKey]) {
        // Determinar LOD baseado na dist√¢ncia
        const lodLevel = getLODLevel(distance);
        chunksToMesh.push([cx, cz, lodLevel]);
      } else {
        // Atualizar LOD de chunks existentes
        const currentLOD = chunkMeshes[chunkKey].userData.lodLevel || 0;
        const newLOD = getLODLevel(distance);

        if (currentLOD !== newLOD) {
          buildChunkMeshWithLOD(cx, cz, newLOD);
        }
      }
    });

    // Limitar chunks processados por frame
    const maxChunksPerFrame = 3;

    chunksToGenerate.slice(0, maxChunksPerFrame).forEach(([cx, cz]) => {
      generateChunk(cx, cz);
      spawnAnimals(cx, cz);
      spawnEnemies(cx, cz);
    });

    chunksToMesh.slice(0, maxChunksPerFrame).forEach(([cx, cz, lodLevel]) => {
      buildChunkMeshWithLOD(cx, cz, lodLevel);
    });

    // Remover chunks distantes
    const chunksToRemove = [];
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const dx = Math.abs(cx - chunk.x);
      const dz = Math.abs(cz - chunk.z);

      if (dx > RENDER_DISTANCE + 2 || dz > RENDER_DISTANCE + 2) {
        chunksToRemove.push(key);
      }
    }

    chunksToRemove.forEach(key => {
      const [cx, cz] = key.split(',').map(Number);
      scene.remove(chunkMeshes[key]);
      chunkMeshes[key].children.forEach(child => {
        child.geometry.dispose();
      });
      delete chunkMeshes[key];
      removeAnimalsInChunk(cx, cz);
      removeEnemiesInChunk(cx, cz);
    });

    updateFaceCount();
  }

  function isChunkInFrustum(cx, cz) {
    const sx = cx * CHUNK_SIZE;
    const sz = cz * CHUNK_SIZE;

    // Criar bounding box do chunk
    const chunkBox = new THREE.Box3(
            new THREE.Vector3(sx, 0, sz),
            new THREE.Vector3(sx + CHUNK_SIZE, 50, sz + CHUNK_SIZE)
    );

    return frustum.intersectsBox(chunkBox);
  }

  function animate() {
    requestAnimationFrame(animate);

    const deltaTime = 0.016;

    if (controls.locked && !document.getElementById('inventory-full').classList.contains('open')) {
      updatePlayer();
      updateBreaking();

      if (multiplayer.connected) {
        syncPlayerPosition();
      }

      if (playerCharacter) {
        const isMoving = keys['KeyW'] || keys['KeyA'] || keys['KeyS'] || keys['KeyD'];
        const isJumping = !player.canJump;
        const isRunning = keys['ShiftLeft'] && isMoving;

        playerCharacter.updateAnimation(deltaTime, isMoving, isJumping, isRunning);

        playerCharacter.setPosition(
                camera.position.x,
                camera.position.y - 2.6,
                camera.position.z
        );
        playerCharacter.setRotation(camera.rotation.y);

        // ‚ú® Atualizar sombras do jogador
        setupPlayerShadows();
      }
    }

    camera.updateMatrixWorld();
    cameraViewProjectionMatrix.multiplyMatrices(
            camera.projectionMatrix,
            camera.matrixWorldInverse
    );
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const mesh = chunkMeshes[key];

      if (mesh) {
        mesh.visible = isChunkInFrustum(cx, cz);
      }
    }

    // Atualizar sistemas
    if (waterSystem) waterSystem.updateWaves(performance.now() * 0.001);
    if (particleSystem) particleSystem.update();
    updateDayNightCycle(deltaTime);
    updateDynamicLighting();

    // ‚ú® ATUALIZAR SOMBRAS DIN√ÇMICAS
    updateDynamicShadows();
    updateSunShadowPosition();

    updateBreakAnimations();
    updateAnimals();
    updateEnemies();
    updateVillagers();

    renderer.render(scene, camera);

    frames++;
    const now = performance.now();

    if (now - lastFaceUpdate > 2000) {
      updateFaceCount();
      lastFaceUpdate = now;
    }

    if (now >= lastTime + 1000) {
      const fps = Math.round(frames * 1000 / (now - lastTime));
      document.getElementById('fps').textContent = fps;
      document.getElementById('fps').className = fps >= 50 ? 'performance-good' : fps >= 30 ? 'performance-ok' : 'performance-bad';

      document.getElementById('pos').textContent =
              `${Math.floor(camera.position.x)}, ${Math.floor(camera.position.y)}, ${Math.floor(camera.position.z)}`;
      document.getElementById('chunks').textContent = Object.keys(chunks).length;
      document.getElementById('total').textContent = Object.keys(worldData).length;
      document.getElementById('animals-count').textContent = `${animals.length} | I:${enemies.length} | A:${villagers.length}`;

      frames = 0;
      lastTime = now;
    }
  }

  function openMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.add('open');
    updateMultiplayerMenuStatus();
  }

  function closeMultiplayerMenu() {
    document.getElementById('multiplayer-menu').classList.remove('open');
  }

  function toggleMultiplayerConnection() {
    if (multiplayer.connected) {
      disconnectMultiplayer();
    } else {
      const serverUrl = document.getElementById('mp-server-url').value;
      const playerName = document.getElementById('mp-player-name').value;

      multiplayer.serverUrl = serverUrl;
      multiplayer.enabled = true;

      connectMultiplayer();

      if (playerName) {
        setTimeout(() => {
          sendMultiplayerMessage({
            type: 'set_name',
            name: playerName
          });
        }, 1000);
      }
    }

    updateMultiplayerMenuStatus();
  }

  function updateMultiplayerMenuStatus() {
    const btn = document.getElementById('mp-connect-btn');
    const status = document.getElementById('mp-connection-status');
    const indicator = document.getElementById('mp-indicator');

    if (multiplayer.connected) {
      btn.textContent = 'Desconectar';
      btn.classList.remove('danger');
      status.textContent = 'Conectado ao servidor';
      indicator.className = 'mp-status-indicator online';
      document.getElementById('multiplayer-status').classList.remove('hidden');
    } else {
      btn.textContent = 'Conectar';
      btn.classList.add('mp-button');
      status.textContent = 'N√£o conectado';
      indicator.className = 'mp-status-indicator offline';
      document.getElementById('multiplayer-status').classList.add('hidden');
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const menuContainer = document.querySelector('.menu-container');
    if (menuContainer) {
      const mpBtn = document.createElement('button');
      mpBtn.className = 'start-button';
      mpBtn.style.background = 'linear-gradient(135deg, #2196F3, #1565C0)';
      mpBtn.innerHTML = 'üåê MULTIPLAYER';
      mpBtn.onclick = openMultiplayerMenu;

      const startBtn = document.querySelector('.start-button');
      if (startBtn) {
        startBtn.parentNode.insertBefore(mpBtn, startBtn.nextSibling);
      }
    }
  });

  function perlinNoise(x, y) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    x -= Math.floor(x);
    y -= Math.floor(y);
    const u = fade(x);
    const v = fade(y);
    const hash = (X * 57 + Y * 113) % 256;
    return lerp(v, lerp(u, grad(hash, x, y), grad(hash + 1, x - 1, y)),
            lerp(u, grad(hash + 1, x, y - 1), grad(hash + 2, x - 1, y - 1)));
  }

  function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  function lerp(t, a, b) { return a + t * (b - a); }
  function grad(hash, x, y) {
    const h = hash & 3;
    return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
  }

  function fractalNoise(x, y, octaves = 4) {
    let total = 0;
    let frequency = 1;
    let amplitude = 1;
    let maxValue = 0;

    for (let i = 0; i < octaves; i++) {
      total += perlinNoise(x * frequency, y * frequency) * amplitude;
      maxValue += amplitude;
      amplitude *= 0.5;
      frequency *= 2;
    }

    return total / maxValue;
  }

  function applyLighting(ctx, x, y, width, height, intensity = 0.3) {
    const gradient = ctx.createRadialGradient(
            x + width * 0.3, y + height * 0.3, 0,
            x + width * 0.5, y + height * 0.5, width
    );
    gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity})`);
    gradient.addColorStop(0.5, `rgba(255, 255, 255, ${intensity * 0.3})`);
    gradient.addColorStop(1, `rgba(0, 0, 0, ${intensity * 0.2})`);
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, width, height);
  }

  function createUltraRealisticGrassTexture(ctx, size) {
    // Base com gradiente complexo
    const bgGradient = ctx.createLinearGradient(0, 0, size, size);
    bgGradient.addColorStop(0, '#6FB849');
    bgGradient.addColorStop(0.2, '#7CFC00');
    bgGradient.addColorStop(0.5, '#6BCD00');
    bgGradient.addColorStop(0.7, '#5AB000');
    bgGradient.addColorStop(1, '#4A9000');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Camada de ru√≠do Perlin para varia√ß√£o natural
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise = fractalNoise(x * 0.1, y * 0.1, 5);
        const factor = 0.7 + noise * 0.3;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Fibras de grama individuais (alta densidade)
    for (let i = 0; i < 200; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const height = 3 + Math.random() * 5;
      const angle = Math.random() * Math.PI / 6 - Math.PI / 12;
      const thickness = 0.3 + Math.random() * 0.5;
      const shade = Math.random() * 60 - 30;
      const alpha = 0.3 + Math.random() * 0.4;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Haste da grama com gradiente
      const grassGrad = ctx.createLinearGradient(0, 0, 0, -height);
      grassGrad.addColorStop(0, `rgba(${60 + shade}, ${120 + shade}, ${20 + shade}, ${alpha})`);
      grassGrad.addColorStop(0.5, `rgba(${80 + shade}, ${180 + shade}, ${30 + shade}, ${alpha})`);
      grassGrad.addColorStop(1, `rgba(${100 + shade}, ${220 + shade}, ${40 + shade}, ${alpha * 0.7})`);

      ctx.strokeStyle = grassGrad;
      ctx.lineWidth = thickness;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(
              Math.random() * 2 - 1, -height * 0.5,
              Math.random() * 2 - 1, -height
      );
      ctx.stroke();

      ctx.restore();
    }

    // Manchas de terra/musgo
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 2 + Math.random() * 6;
      const shade = Math.random() * 40 - 20;

      const dirtGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      dirtGrad.addColorStop(0, `rgba(${90 + shade}, ${70 + shade}, ${30 + shade}, 0.6)`);
      dirtGrad.addColorStop(0.5, `rgba(${70 + shade}, ${50 + shade}, ${20 + shade}, 0.4)`);
      dirtGrad.addColorStop(1, `rgba(${70 + shade}, ${50 + shade}, ${20 + shade}, 0)`);
      ctx.fillStyle = dirtGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Orvalho/got√≠culas de √°gua
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.5 + Math.random() * 1.5;

      // Got√≠cula com reflexo
      const dropGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
      dropGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
      dropGrad.addColorStop(0.4, 'rgba(200, 230, 255, 0.6)');
      dropGrad.addColorStop(1, 'rgba(150, 200, 230, 0.3)');
      ctx.fillStyle = dropGrad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(x - r * 0.4, y - r * 0.4, r * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Sombras de grama (ambient occlusion)
    ctx.fillStyle = 'rgba(0, 30, 0, 0.1)';
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      ctx.fillRect(x, y, 2, 2);
    }

    // Ilumina√ß√£o geral
    applyLighting(ctx, 0, 0, size, size, 0.15);
  }

  function createUltraRealisticDirtTexture(ctx, size) {
    // Base com gradiente complexo
    const bgGradient = ctx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, size * 0.8);
    bgGradient.addColorStop(0, '#9B6B3F');
    bgGradient.addColorStop(0.5, '#8B4513');
    bgGradient.addColorStop(1, '#6B3410');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do Perlin para textura base
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise1 = fractalNoise(x * 0.08, y * 0.08, 4);
        const noise2 = fractalNoise(x * 0.15, y * 0.15, 3);
        const factor = 0.6 + noise1 * 0.3 + noise2 * 0.1;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Agregados de terra (torr√µes)
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 8;
      const shade = Math.random() * 50 - 25;
      const segments = 6 + Math.floor(Math.random() * 6);

      ctx.fillStyle = `rgba(${120 + shade}, ${80 + shade}, ${40 + shade}, ${0.5 + Math.random() * 0.3})`;
      ctx.beginPath();

      for (let j = 0; j <= segments; j++) {
        const angle = (j / segments) * Math.PI * 2;
        const r = radius * (0.8 + Math.random() * 0.4);
        const px = x + Math.cos(angle) * r;
        const py = y + Math.sin(angle) * r;

        if (j === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();

      // Sombra do torr√£o
      ctx.fillStyle = 'rgba(40, 25, 10, 0.4)';
      ctx.beginPath();
      ctx.ellipse(x + 1, y + 2, radius * 0.8, radius * 0.4, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    // Pedrinhas e cascalho
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const w = 1 + Math.random() * 4;
      const h = 1 + Math.random() * 3;
      const shade = Math.random() * 60;

      // Pedrinha com forma irregular
      ctx.fillStyle = `rgba(${100 + shade}, ${100 + shade}, ${100 + shade}, ${0.6 + Math.random() * 0.3})`;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.random() * Math.PI);
      ctx.fillRect(-w/2, -h/2, w, h);

      // Brilho na pedrinha
      ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
      ctx.fillRect(-w/2, -h/2, w * 0.4, h * 0.4);

      // Sombra
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fillRect(w/4, h/4, w * 0.4, h * 0.4);

      ctx.restore();
    }

    // Ra√≠zes e material org√¢nico
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const length = 10 + Math.random() * 20;
      const segments = 5 + Math.floor(Math.random() * 5);

      ctx.strokeStyle = `rgba(${50 + Math.random() * 30}, ${30 + Math.random() * 20}, ${10 + Math.random() * 10}, ${0.4 + Math.random() * 0.3})`;
      ctx.lineWidth = 0.5 + Math.random() * 1.5;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 8;
        currentY += (Math.random() - 0.5) * 8;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();
    }

    // Manchas de umidade
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 4 + Math.random() * 10;

      const wetGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      wetGrad.addColorStop(0, 'rgba(60, 40, 20, 0.5)');
      wetGrad.addColorStop(0.5, 'rgba(70, 50, 25, 0.3)');
      wetGrad.addColorStop(1, 'rgba(80, 60, 30, 0)');
      ctx.fillStyle = wetGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Textura micro-detalhada
    for (let i = 0; i < size * 3; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const shade = Math.random() * 40 - 20;
      ctx.fillStyle = `rgba(${100 + shade}, ${70 + shade}, ${40 + shade}, 0.2)`;
      ctx.fillRect(x, y, 1, 1);
    }

    // Ilumina√ß√£o direcional
    applyLighting(ctx, 0, 0, size, size, 0.2);
  }

  function createUltraRealisticStoneTexture(ctx, size) {
    // Base com gradiente radial
    const bgGradient = ctx.createRadialGradient(size * 0.3, size * 0.3, 0, size * 0.5, size * 0.5, size);
    bgGradient.addColorStop(0, '#9A9A9A');
    bgGradient.addColorStop(0.5, '#808080');
    bgGradient.addColorStop(1, '#606060');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do Perlin multi-oitava
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise1 = fractalNoise(x * 0.05, y * 0.05, 6);
        const noise2 = fractalNoise(x * 0.2, y * 0.2, 3);
        const factor = 0.5 + noise1 * 0.4 + noise2 * 0.1;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Forma√ß√µes rochosas (camadas sedimentares)
    for (let layer = 0; layer < 8; layer++) {
      const y = (layer / 8) * size + Math.random() * 8;
      const thickness = 2 + Math.random() * 4;
      const shade = Math.random() * 60 - 30;

      ctx.fillStyle = `rgba(${128 + shade}, ${128 + shade}, ${128 + shade}, ${0.2 + Math.random() * 0.3})`;
      ctx.fillRect(0, y, size, thickness);

      // Varia√ß√£o dentro da camada
      for (let i = 0; i < size / 2; i++) {
        const x = Math.random() * size;
        const localShade = Math.random() * 30 - 15;
        ctx.fillStyle = `rgba(${128 + shade + localShade}, ${128 + shade + localShade}, ${128 + shade + localShade}, 0.3)`;
        ctx.fillRect(x, y, 4, thickness);
      }
    }

    // Veios minerais complexos
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const segments = 5 + Math.floor(Math.random() * 8);
      const veinType = Math.random();

      let color;
      if (veinType < 0.3) {
        color = `rgba(${180 + Math.random() * 40}, ${180 + Math.random() * 40}, ${180 + Math.random() * 40}, 0.5)`;
      } else if (veinType < 0.6) {
        color = `rgba(${140 + Math.random() * 30}, ${120 + Math.random() * 30}, ${100 + Math.random() * 30}, 0.4)`;
      } else {
        color = `rgba(${100 + Math.random() * 30}, ${100 + Math.random() * 30}, ${120 + Math.random() * 40}, 0.4)`;
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 0.5 + Math.random() * 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 12;
        currentY += (Math.random() - 0.5) * 12;
        ctx.lineTo(currentX, currentY);

        // Ramifica√ß√µes
        if (Math.random() > 0.7) {
          const branchX = currentX + (Math.random() - 0.5) * 8;
          const branchY = currentY + (Math.random() - 0.5) * 8;
          ctx.moveTo(currentX, currentY);
          ctx.lineTo(branchX, branchY);
          ctx.moveTo(currentX, currentY);
        }
      }
      ctx.stroke();
    }

    // Rachaduras profundas e realistas
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const segments = 3 + Math.floor(Math.random() * 5);

      // Sombra da rachadura
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.lineWidth = 1 + Math.random() * 2;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, y);

      let currentX = x;
      let currentY = y;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 10;
        currentY += (Math.random() - 0.5) * 10;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();

      // Luz na borda da rachadura
      ctx.strokeStyle = 'rgba(160, 160, 160, 0.3)';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Cristais pequenos e brilhantes
    for (let i = 0; i < 50; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const size_crystal = 0.5 + Math.random() * 2;

      // Cristal
      ctx.fillStyle = `rgba(${220 + Math.random() * 35}, ${220 + Math.random() * 35}, ${240 + Math.random() * 15}, ${0.4 + Math.random() * 0.4})`;
      ctx.fillRect(x, y, size_crystal, size_crystal);

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
      ctx.fillRect(x, y, size_crystal * 0.5, size_crystal * 0.5);
    }

    // Poros e imperfei√ß√µes
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.3 + Math.random() * 1;

      ctx.fillStyle = 'rgba(40, 40, 40, 0.5)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o direcional forte
    applyLighting(ctx, 0, 0, size, size, 0.25);
  }

  function createUltraRealisticWoodTexture(ctx, size) {
    // Base com gradiente de madeira
    const bgGradient = ctx.createLinearGradient(0, 0, size, 0);
    bgGradient.addColorStop(0, '#7A5230');
    bgGradient.addColorStop(0.5, '#654321');
    bgGradient.addColorStop(1, '#5A3A1F');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Centro do tronco
    const centerX = size / 2 + (Math.random() - 0.5) * size * 0.2;
    const centerY = size / 2 + (Math.random() - 0.5) * size * 0.2;

    // An√©is de crescimento ultra-realistas
    const numRings = 15 + Math.floor(Math.random() * 10);
    const maxRadius = Math.sqrt(2) * size;

    for (let ring = 0; ring < numRings; ring++) {
      const baseRadius = (ring / numRings) * maxRadius;
      const thickness = 2 + Math.random() * 5;
      const isDarkRing = ring % 2 === 0;
      const shade = isDarkRing ? -20 - Math.random() * 20 : 10 + Math.random() * 20;
      const opacity = 0.3 + Math.random() * 0.4;

      ctx.strokeStyle = `rgba(${80 + shade}, ${50 + shade}, ${20 + shade}, ${opacity})`;
      ctx.lineWidth = thickness;

      ctx.beginPath();

      // Anel irregular e natural
      for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
        const noise1 = perlinNoise(Math.cos(angle) * 2, Math.sin(angle) * 2);
        const noise2 = perlinNoise(Math.cos(angle * 3) * 0.5, Math.sin(angle * 3) * 0.5);
        const variation = noise1 * 8 + noise2 * 3;
        const radius = baseRadius + variation;

        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;

        if (angle === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.closePath();
      ctx.stroke();

      // Varia√ß√£o de densidade dentro do anel
      if (isDarkRing) {
        ctx.strokeStyle = `rgba(${60 + shade}, ${40 + shade}, ${15 + shade}, ${opacity * 0.5})`;
        ctx.lineWidth = thickness * 0.3;
        ctx.stroke();
      }
    }

    // Veios verticais (fibras da madeira)
    for (let i = 0; i < 80; i++) {
      const x = Math.random() * size;
      const segments = 3 + Math.floor(Math.random() * 4);
      const shade = Math.random() * 40 - 20;

      ctx.strokeStyle = `rgba(${70 + shade}, ${45 + shade}, ${18 + shade}, ${0.15 + Math.random() * 0.2})`;
      ctx.lineWidth = 0.3 + Math.random() * 1;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(x, 0);

      let currentX = x;
      let currentY = 0;

      for (let j = 0; j < segments; j++) {
        currentX += (Math.random() - 0.5) * 3;
        currentY += size / segments;
        ctx.lineTo(currentX, currentY);
      }
      ctx.stroke();
    }

    // N√≥s da madeira (defeitos naturais)
    const numKnots = 2 + Math.floor(Math.random() * 4);
    for (let i = 0; i < numKnots; i++) {
      const kx = Math.random() * size;
      const ky = Math.random() * size;
      const kRadius = 4 + Math.random() * 12;
      const shade = -30 - Math.random() * 30;

      // C√≠rculos conc√™ntricos do n√≥
      for (let r = 0; r < kRadius; r += 0.5 + Math.random()) {
        const ringShade = shade + Math.random() * 20;
        const alpha = 0.3 + (1 - r / kRadius) * 0.5;

        ctx.strokeStyle = `rgba(${60 + ringShade}, ${40 + ringShade}, ${15 + ringShade}, ${alpha})`;
        ctx.lineWidth = 1 + Math.random() * 2;

        ctx.beginPath();

        // N√≥ irregular
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.2) {
          const noise = perlinNoise(Math.cos(angle) * 5, Math.sin(angle) * 5);
          const radius = r + noise * 2;
          const x = kx + Math.cos(angle) * radius;
          const y = ky + Math.sin(angle) * radius;

          if (angle === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Centro do n√≥ (mais escuro)
      const centerGrad = ctx.createRadialGradient(kx, ky, 0, kx, ky, kRadius * 0.3);
      centerGrad.addColorStop(0, `rgba(${40 + shade}, ${25 + shade}, ${10 + shade}, 0.8)`);
      centerGrad.addColorStop(1, `rgba(${50 + shade}, ${30 + shade}, ${12 + shade}, 0.4)`);
      ctx.fillStyle = centerGrad;
      ctx.beginPath();
      ctx.arc(kx, ky, kRadius * 0.3, 0, Math.PI * 2);
      ctx.fill();
    }

    // Textura de poros (pequenos buracos)
    for (let i = 0; i < 150; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.2 + Math.random() * 0.8;

      ctx.fillStyle = 'rgba(40, 25, 10, 0.4)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Manchas e varia√ß√µes de cor
    for (let i = 0; i < 30; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 10;
      const shade = Math.random() * 30 - 15;

      const spotGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      spotGrad.addColorStop(0, `rgba(${90 + shade}, ${60 + shade}, ${30 + shade}, 0.3)`);
      spotGrad.addColorStop(1, `rgba(${90 + shade}, ${60 + shade}, ${30 + shade}, 0)`);
      ctx.fillStyle = spotGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o com reflexos de verniz
    applyLighting(ctx, 0, 0, size, size, 0.18);

    // Brilho especular (verniz)
    const glossGrad = ctx.createRadialGradient(size * 0.3, size * 0.3, 0, size * 0.5, size * 0.5, size * 0.8);
    glossGrad.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
    glossGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
    glossGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = glossGrad;
    ctx.fillRect(0, 0, size, size);
  }

  function createUltraRealisticLeavesTexture(ctx, size) {
    // Base verde com varia√ß√£o
    const bgGradient = ctx.createRadialGradient(size * 0.4, size * 0.4, 0, size * 0.5, size * 0.5, size);
    bgGradient.addColorStop(0, '#32A832');
    bgGradient.addColorStop(0.5, '#228B22');
    bgGradient.addColorStop(1, '#1A6B1A');
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, size, size);

    // Ru√≠do de fundo para densidade
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;

    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const i = (y * size + x) * 4;
        const noise = fractalNoise(x * 0.12, y * 0.12, 4);
        const factor = 0.6 + noise * 0.4;

        data[i] = Math.floor(data[i] * factor);
        data[i + 1] = Math.floor(data[i + 1] * factor);
        data[i + 2] = Math.floor(data[i + 2] * factor);
      }
    }
    ctx.putImageData(imageData, 0, 0);

    // Folhas individuais detalhadas
    for (let i = 0; i < 100; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const leafSize = 3 + Math.random() * 6;
      const angle = Math.random() * Math.PI * 2;
      const shade = Math.random() * 80 - 40;
      const alpha = 0.4 + Math.random() * 0.4;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Forma da folha (el√≠ptica com ponta)
      const leafGrad = ctx.createLinearGradient(-leafSize, 0, leafSize, 0);
      leafGrad.addColorStop(0, `rgba(${40 + shade}, ${160 + shade}, ${40 + shade}, ${alpha})`);
      leafGrad.addColorStop(0.5, `rgba(${50 + shade}, ${200 + shade}, ${50 + shade}, ${alpha})`);
      leafGrad.addColorStop(1, `rgba(${45 + shade}, ${180 + shade}, ${45 + shade}, ${alpha * 0.8})`);

      ctx.fillStyle = leafGrad;
      ctx.beginPath();
      ctx.ellipse(0, 0, leafSize, leafSize * 1.6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Nervura central
      ctx.strokeStyle = `rgba(${30 + shade}, ${120 + shade}, ${30 + shade}, ${alpha * 0.8})`;
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.moveTo(0, -leafSize * 1.4);
      ctx.lineTo(0, leafSize * 1.4);
      ctx.stroke();

      // Nervuras secund√°rias
      for (let j = 0; j < 4; j++) {
        const offset = (j - 1.5) * leafSize * 0.5;
        ctx.beginPath();
        ctx.moveTo(0, offset);
        ctx.lineTo(-leafSize * 0.7, offset - leafSize * 0.3);
        ctx.moveTo(0, offset);
        ctx.lineTo(leafSize * 0.7, offset - leafSize * 0.3);
        ctx.stroke();
      }

      // Destaque (reflexo de luz)
      ctx.fillStyle = `rgba(150, 255, 100, ${alpha * 0.3})`;
      ctx.beginPath();
      ctx.ellipse(-leafSize * 0.3, -leafSize * 0.5, leafSize * 0.3, leafSize * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // √Åreas de sombra (profundidade)
    for (let i = 0; i < 40; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 4 + Math.random() * 10;

      const shadowGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      shadowGrad.addColorStop(0, 'rgba(10, 50, 10, 0.5)');
      shadowGrad.addColorStop(0.5, 'rgba(20, 70, 20, 0.3)');
      shadowGrad.addColorStop(1, 'rgba(20, 70, 20, 0)');
      ctx.fillStyle = shadowGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // √Åreas iluminadas (luz solar filtrada)
    for (let i = 0; i < 25; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const radius = 3 + Math.random() * 8;

      const lightGrad = ctx.createRadialGradient(x, y, 0, x, y, radius);
      lightGrad.addColorStop(0, 'rgba(150, 255, 100, 0.4)');
      lightGrad.addColorStop(0.5, 'rgba(100, 230, 80, 0.2)');
      lightGrad.addColorStop(1, 'rgba(100, 230, 80, 0)');
      ctx.fillStyle = lightGrad;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Buracos e imperfei√ß√µes (insetos)
    for (let i = 0; i < 15; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 1 + Math.random() * 3;

      // Buraco com sombra
      ctx.fillStyle = 'rgba(0, 20, 0, 0.7)';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Borda do buraco
      ctx.strokeStyle = 'rgba(60, 40, 20, 0.5)';
      ctx.lineWidth = 0.5;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Got√≠culas de √°gua
    for (let i = 0; i < 20; i++) {
      const x = Math.random() * size;
      const y = Math.random() * size;
      const r = 0.8 + Math.random() * 2;

      const dropGrad = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);
      dropGrad.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
      dropGrad.addColorStop(0.4, 'rgba(200, 240, 255, 0.5)');
      dropGrad.addColorStop(1, 'rgba(150, 220, 240, 0.2)');
      ctx.fillStyle = dropGrad;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();

      // Brilho especular
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(x - r * 0.4, y - r * 0.4, r * 0.35, 0, Math.PI * 2);
      ctx.fill();
    }

    // Ilumina√ß√£o ambiente
    applyLighting(ctx, 0, 0, size, size, 0.12);
  }

  function createMaterialsWithEmissive() {
    for (let type in blockTypes) {
      const block = blockTypes[type];
      let texture;

      // Criar textura apropriada para cada tipo
      if (['grass', 'dirt', 'stone', 'wood', 'leaves'].includes(type)) {
        // Usar texturas ultra-realistas para blocos principais
        texture = createUltraRealisticTexture(type, 128);
      } else {
        // Usar texturas normais para outros blocos
        texture = createTexture(type, 64);
      }

      // Criar material baseado no tipo de bloco
      if (block.emissive) {
        materials[type] = new THREE.MeshBasicMaterial({
          map: texture,
          emissive: block.color,
          emissiveIntensity: 0.8
        });
      } else if (type === 'glass' || type === 'ice') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.7,
          side: THREE.DoubleSide
        });
      } else if (type === 'water') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
      } else if (type === 'leaves') {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
          alphaTest: 0.5
        });
      } else {
        materials[type] = new THREE.MeshLambertMaterial({
          map: texture,
          flatShading: false
        });
      }
    }
  }

  // Nova fun√ß√£o centralizada para texturas ultra-realistas
  function createUltraRealisticTexture(type, size) {
    if (textureCache[type]) return textureCache[type];

    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    switch(type) {
      case 'grass':
        createUltraRealisticGrassTexture(ctx, size);
        break;
      case 'dirt':
        createUltraRealisticDirtTexture(ctx, size);
        break;
      case 'stone':
        createUltraRealisticStoneTexture(ctx, size);
        break;
      case 'wood':
        createUltraRealisticWoodTexture(ctx, size);
        break;
      case 'leaves':
        createUltraRealisticLeavesTexture(ctx, size);
        break;
      default:
        // Fallback para textura b√°sica
        createDefaultTexture(ctx, size, blockTypes[type]?.color || 0x808080);
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.magFilter = THREE.LinearFilter;
    texture.minFilter = THREE.LinearMipmapLinearFilter;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;

    // Verificar se renderer existe antes de usar anisotropy
    if (renderer && renderer.capabilities) {
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    }

    textureCache[type] = texture;
    return texture;
  }
  const lightingSystem = {
    lights: new Map(),
    maxLights: 50, // Limite para performance
    lightRange: 12,
    updateQueue: []
  };

  function updateDynamicLighting() {
    const playerPos = camera.position;
    const updateRadius = 30;

    lightingSystem.lights.forEach((lightData, key) => {
      const dx = lightData.x - playerPos.x;
      const dy = lightData.y - playerPos.y;
      const dz = lightData.z - playerPos.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

      // Otimiza√ß√£o: desativar luzes muito distantes
      if (dist > updateRadius) {
        lightData.light.visible = false;
      } else {
        lightData.light.visible = true;

        // Efeito de cintila√ß√£o suave para tochas
        if (lightData.type === 'torch') {
          const flicker = 0.95 + Math.sin(Date.now() * 0.01 + lightData.x) * 0.05;
          lightData.light.intensity = 1.5 * flicker;
        }
      }
    });
  }

  function addWaterLighting(x, y, z) {
    const waterLight = new THREE.PointLight(0x4499FF, 0.3, 8);
    waterLight.position.set(x, y, z);
    scene.add(waterLight);

    return waterLight;
  }

  const shadowSystem = {
    quality: 'high', // 'low', 'medium', 'high', 'ultra'
    enabled: true,
    dynamicShadows: true,
    shadowDistance: 50,
    cascadeShadows: false
  };

  function setupShadowSystem() {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras suaves
    renderer.shadowMap.autoUpdate = true;

    // Configura√ß√µes de qualidade
    updateShadowQuality(shadowSystem.quality);
  }

  function updateShadowQuality(quality) {
    let mapSize, bias;

    switch(quality) {
      case 'low':
        mapSize = 512;
        bias = -0.001;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        break;
      case 'medium':
        mapSize = 1024;
        bias = -0.0005;
        renderer.shadowMap.type = THREE.PCFShadowMap;
        break;
      case 'high':
        mapSize = 2048;
        bias = -0.0001;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        break;
      case 'ultra':
        mapSize = 4096;
        bias = -0.00005;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        break;
      default:
        mapSize = 2048;
        bias = -0.0001;
    }

    shadowSystem.quality = quality;

    // Atualizar todas as luzes existentes
    scene.traverse(obj => {
      if (obj.isLight && obj.castShadow) {
        obj.shadow.mapSize.width = mapSize;
        obj.shadow.mapSize.height = mapSize;
        obj.shadow.bias = bias;
        obj.shadow.needsUpdate = true;
      }
    });
  }

  function setupSunShadows(sunLight) {
    sunLight.castShadow = true;

    // Configura√ß√£o de alta qualidade para o sol
    sunLight.shadow.mapSize.width = 4096;
    sunLight.shadow.mapSize.height = 4096;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;

    // √Årea de sombra grande
    const shadowSize = 100;
    sunLight.shadow.camera.left = -shadowSize;
    sunLight.shadow.camera.right = shadowSize;
    sunLight.shadow.camera.top = shadowSize;
    sunLight.shadow.camera.bottom = -shadowSize;

    sunLight.shadow.bias = -0.0001;
    sunLight.shadow.radius = 2; // Sombras mais suaves

    return sunLight;
  }

  function enableShadowsForChunk(chunkKey) {
    const chunkMesh = chunkMeshes[chunkKey];
    if (!chunkMesh) return;

    chunkMesh.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;

        // Otimiza√ß√£o: apenas blocos pr√≥ximos projetam sombras
        child.userData.updateShadow = true;
      }
    });
  }

  function updateDynamicShadows() {
    if (!shadowSystem.dynamicShadows) return;

    const playerPos = camera.position;
    const shadowRadius = shadowSystem.shadowDistance;

    // Atualizar sombras apenas para chunks pr√≥ximos
    for (let key in chunkMeshes) {
      const [cx, cz] = key.split(',').map(Number);
      const chunkCenterX = cx * CHUNK_SIZE + CHUNK_SIZE / 2;
      const chunkCenterZ = cz * CHUNK_SIZE + CHUNK_SIZE / 2;

      const dx = chunkCenterX - playerPos.x;
      const dz = chunkCenterZ - playerPos.z;
      const dist = Math.sqrt(dx * dx + dz * dz);

      const chunk = chunkMeshes[key];
      if (chunk) {
        chunk.traverse(child => {
          if (child.isMesh) {
            // Ativar/desativar sombras baseado na dist√¢ncia
            const shouldCastShadow = dist < shadowRadius;
            child.castShadow = shouldCastShadow;
            child.receiveShadow = true; // Sempre recebe sombras
          }
        });
      }
    }

    // Atualizar sombras de entidades
    [animals, enemies, villagers].forEach(entityList => {
      entityList.forEach(entity => {
        if (entity.mesh) {
          const dx = entity.x - playerPos.x;
          const dz = entity.z - playerPos.z;
          const dist = Math.sqrt(dx * dx + dz * dz);

          entity.mesh.traverse(child => {
            if (child.isMesh) {
              child.castShadow = dist < shadowRadius;
              child.receiveShadow = true;
            }
          });
        }
      });
    });
  }

  function setupPlayerShadows() {
    if (playerCharacter && playerCharacter.group) {
      playerCharacter.group.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
    }
  }

  function addAmbientOcclusion() {
    // Adicionar luz hemisf√©rica para AO
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 100, 0);
    scene.add(hemiLight);

    return hemiLight;
  }

  function addVolumetricShadows() {
    const volumetricLight = new THREE.SpotLight(0xffffff, 0.5);
    volumetricLight.position.set(50, 100, 50);
    volumetricLight.angle = Math.PI / 4;
    volumetricLight.penumbra = 0.8;
    volumetricLight.decay = 2;
    volumetricLight.distance = 300;

    volumetricLight.castShadow = true;
    volumetricLight.shadow.mapSize.width = 2048;
    volumetricLight.shadow.mapSize.height = 2048;
    volumetricLight.shadow.camera.near = 1;
    volumetricLight.shadow.camera.far = 300;
    volumetricLight.shadow.bias = -0.0001;

    scene.add(volumetricLight);

    return volumetricLight;
  }

  function updateSunShadowPosition() {
    scene.traverse(obj => {
      if (obj.isDirectionalLight && obj.castShadow) {
        // Seguir o jogador para sombras sempre vis√≠veis
        const playerPos = camera.position;
        obj.shadow.camera.position.copy(playerPos);
        obj.shadow.camera.updateProjectionMatrix();
        obj.shadow.needsUpdate = true;
      }
    });
  }

  function enableSoftShadows() {
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    scene.traverse(obj => {
      if (obj.isLight && obj.shadow) {
        obj.shadow.radius = 3; // Aumentar suavidade
        obj.shadow.needsUpdate = true;
      }
    });
  }


  init();
</script>
</body>
</html>